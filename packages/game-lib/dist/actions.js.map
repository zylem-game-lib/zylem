{"version":3,"sources":["../src/lib/actions/behaviors/actions.ts","../src/lib/actions/capabilities/moveable.ts","../src/lib/actions/capabilities/rotatable.ts","../src/lib/actions/capabilities/transformable.ts"],"sourcesContent":["// TODO: rewrite these functions to work well within game loop\n\nexport function wait(delay: number, callback: Function) {\n\t// TODO: needs ticks from loop\n\tsetTimeout(callback, delay);\n}\n\nexport const actionOnPress = (() => {\n\tlet buttonPressed = false;\n\n\treturn (isPressed: boolean, callback: Function) => {\n\t\tif (isPressed && !buttonPressed) {\n\t\t\tbuttonPressed = true;\n\t\t\tcallback();\n\t\t} else if (!isPressed) {\n\t\t\tbuttonPressed = false;\n\t\t}\n\t};\n})();\n\nexport const actionOnRelease = (() => {\n\tlet buttonPressed = false;\n\n\treturn (isPressed: boolean, callback: Function) => {\n\t\tif (!isPressed && buttonPressed) {\n\t\t\tbuttonPressed = false;\n\t\t\tcallback();\n\t\t} else if (isPressed) {\n\t\t\tbuttonPressed = true;\n\t\t}\n\t};\n})();\n\ntype CooldownOptions = { timer: number; immediate?: boolean };\n\nexport const actionWithCooldown = (() => {\n\tlet lastExecutionTime = -Infinity;\n\tlet flagImmediate = false;\n\n\treturn ({ timer, immediate = true }: CooldownOptions, callback: Function, update: Function) => {\n\t\tlet currentTime = Date.now();\n\n\t\tif (!flagImmediate && !immediate) {\n\t\t\tflagImmediate = true;\n\t\t\tlastExecutionTime = currentTime;\n\t\t}\n\n\t\tconst delta = currentTime - lastExecutionTime;\n\n\t\tif (delta >= timer) {\n\t\t\tlastExecutionTime = currentTime;\n\t\t\tcallback();\n\t\t}\n\t\tupdate({ delta });\n\t};\n})();\n\nexport const actionWithThrottle = (() => {\n\tlet lastExecutionTime = 0;\n\n\treturn (timer: number, callback: Function) => {\n\t\tconst currentTime = Date.now();\n\t\tconst delta = currentTime - lastExecutionTime;\n\n\t\tif (delta >= timer) {\n\t\t\tlastExecutionTime = currentTime;\n\t\t\tcallback();\n\t\t}\n\t};\n})();\n","import { Vector3 } from 'three';\nimport { RigidBody, Vector } from '@dimforge/rapier3d-compat';\n\nexport interface EntityWithBody {\n\tbody: RigidBody | null;\n}\n\n/**\n * Move an entity along the X axis, preserving other velocities\n */\nexport function moveX(entity: EntityWithBody, delta: number): void {\n\tif (!entity.body) return;\n\tconst currentVelocity = entity.body.linvel();\n\tconst newVelocity = new Vector3(delta, currentVelocity.y, currentVelocity.z);\n\tentity.body.setLinvel(newVelocity, true);\n}\n\n/**\n * Move an entity along the Y axis, preserving other velocities\n */\nexport function moveY(entity: EntityWithBody, delta: number): void {\n\tif (!entity.body) return;\n\tconst currentVelocity = entity.body.linvel();\n\tconst newVelocity = new Vector3(currentVelocity.x, delta, currentVelocity.z);\n\tentity.body.setLinvel(newVelocity, true);\n}\n\n/**\n * Move an entity along the Z axis, preserving other velocities\n */\nexport function moveZ(entity: EntityWithBody, delta: number): void {\n\tif (!entity.body) return;\n\tconst currentVelocity = entity.body.linvel();\n\tconst newVelocity = new Vector3(currentVelocity.x, currentVelocity.y, delta);\n\tentity.body.setLinvel(newVelocity, true);\n}\n\n/**\n * Move an entity along the X and Y axis, preserving Z velocity\n */\nexport function moveXY(entity: EntityWithBody, deltaX: number, deltaY: number): void {\n\tif (!entity.body) return;\n\tconst currentVelocity = entity.body.linvel();\n\tconst newVelocity = new Vector3(deltaX, deltaY, currentVelocity.z);\n\tentity.body.setLinvel(newVelocity, true);\n}\n\n/**\n * Move an entity along the X and Z axis, preserving Y velocity\n */\nexport function moveXZ(entity: EntityWithBody, deltaX: number, deltaZ: number): void {\n\tif (!entity.body) return;\n\tconst currentVelocity = entity.body.linvel();\n\tconst newVelocity = new Vector3(deltaX, currentVelocity.y, deltaZ);\n\tentity.body.setLinvel(newVelocity, true);\n}\n\n/**\n * Move entity based on a vector, adding to existing velocities\n */\nexport function move(entity: EntityWithBody, vector: Vector3): void {\n\tif (!entity.body) return;\n\tconst currentVelocity = entity.body.linvel();\n\tconst newVelocity = new Vector3(\n\t\tcurrentVelocity.x + vector.x,\n\t\tcurrentVelocity.y + vector.y,\n\t\tcurrentVelocity.z + vector.z\n\t);\n\tentity.body.setLinvel(newVelocity, true);\n}\n\n/**\n * Reset entity velocity\n */\nexport function resetVelocity(entity: EntityWithBody): void {\n\tif (!entity.body) return;\n\tentity.body.setLinvel(new Vector3(0, 0, 0), true);\n\tentity.body.setLinearDamping(5);\n}\n\n/**\n * Move entity forward in 2D space, preserving Z velocity\n */\nexport function moveForwardXY(entity: EntityWithBody, delta: number, rotation2DAngle: number): void {\n\tconst deltaX = Math.sin(-rotation2DAngle) * delta;\n\tconst deltaY = Math.cos(-rotation2DAngle) * delta;\n\tmoveXY(entity, deltaX, deltaY);\n}\n\n/**\n * Get entity position\n */\nexport function getPosition(entity: EntityWithBody): Vector | null {\n\tif (!entity.body) return null;\n\treturn entity.body.translation();\n}\n\n/**\n * Get entity velocity\n */\nexport function getVelocity(entity: EntityWithBody): Vector | null {\n\tif (!entity.body) return null;\n\treturn entity.body.linvel();\n}\n\n/**\n * Set entity position\n */\nexport function setPosition(entity: EntityWithBody, x: number, y: number, z: number): void {\n\tif (!entity.body) return;\n\tentity.body.setTranslation({ x, y, z }, true);\n}\n\n/**\n * Set entity X position\n */\nexport function setPositionX(entity: EntityWithBody, x: number): void {\n\tif (!entity.body) return;\n\tconst { y, z } = entity.body.translation();\n\tentity.body.setTranslation({ x, y, z }, true);\n}\n\n/**\n * Set entity Y position\n */\nexport function setPositionY(entity: EntityWithBody, y: number): void {\n\tif (!entity.body) return;\n\tconst { x, z } = entity.body.translation();\n\tentity.body.setTranslation({ x, y, z }, true);\n}\n\n/**\n * Set entity Z position\n */\nexport function setPositionZ(entity: EntityWithBody, z: number): void {\n\tif (!entity.body) return;\n\tconst { x, y } = entity.body.translation();\n\tentity.body.setTranslation({ x, y, z }, true);\n}\n\n/**\n * Wrap entity around 2D bounds\n */\nexport function wrapAroundXY(entity: EntityWithBody, boundsX: number, boundsY: number): void {\n\tconst position = getPosition(entity);\n\tif (!position) return;\n\n\tconst { x, y } = position;\n\tconst newX = x > boundsX ? -boundsX : (x < -boundsX ? boundsX : x);\n\tconst newY = y > boundsY ? -boundsY : (y < -boundsY ? boundsY : y);\n\n\tif (newX !== x || newY !== y) {\n\t\tsetPosition(entity, newX, newY, 0);\n\t}\n}\n\n/**\n * Wrap entity around 3D bounds\n */\nexport function wrapAround3D(entity: EntityWithBody, boundsX: number, boundsY: number, boundsZ: number): void {\n\tconst position = getPosition(entity);\n\tif (!position) return;\n\n\tconst { x, y, z } = position;\n\tconst newX = x > boundsX ? -boundsX : (x < -boundsX ? boundsX : x);\n\tconst newY = y > boundsY ? -boundsY : (y < -boundsY ? boundsY : y);\n\tconst newZ = z > boundsZ ? -boundsZ : (z < -boundsZ ? boundsZ : z);\n\n\tif (newX !== x || newY !== y || newZ !== z) {\n\t\tsetPosition(entity, newX, newY, newZ);\n\t}\n}\n\n/**\n * Enhanced moveable entity with bound methods\n */\nexport interface MoveableEntity extends EntityWithBody {\n\tmoveX(delta: number): void;\n\tmoveY(delta: number): void;\n\tmoveZ(delta: number): void;\n\tmoveXY(deltaX: number, deltaY: number): void;\n\tmoveXZ(deltaX: number, deltaZ: number): void;\n\tmove(vector: Vector3): void;\n\tresetVelocity(): void;\n\tmoveForwardXY(delta: number, rotation2DAngle: number): void;\n\tgetPosition(): Vector | null;\n\tgetVelocity(): Vector | null;\n\tsetPosition(x: number, y: number, z: number): void;\n\tsetPositionX(x: number): void;\n\tsetPositionY(y: number): void;\n\tsetPositionZ(z: number): void;\n\twrapAroundXY(boundsX: number, boundsY: number): void;\n\twrapAround3D(boundsX: number, boundsY: number, boundsZ: number): void;\n}\n\n/**\n * Class decorator to enhance an entity with additive movement methods\n */\nexport function moveable<T extends { new(...args: any[]): EntityWithBody }>(constructor: T) {\n\treturn class extends constructor implements MoveableEntity {\n\t\tmoveX(delta: number): void {\n\t\t\tmoveX(this, delta);\n\t\t}\n\t\tmoveY(delta: number): void {\n\t\t\tmoveY(this, delta);\n\t\t}\n\t\tmoveZ(delta: number): void {\n\t\t\tmoveZ(this, delta);\n\t\t}\n\t\tmoveXY(deltaX: number, deltaY: number): void {\n\t\t\tmoveXY(this, deltaX, deltaY);\n\t\t}\n\t\tmoveXZ(deltaX: number, deltaZ: number): void {\n\t\t\tmoveXZ(this, deltaX, deltaZ);\n\t\t}\n\t\tmove(vector: Vector3): void {\n\t\t\tmove(this, vector);\n\t\t}\n\t\tresetVelocity(): void {\n\t\t\tresetVelocity(this);\n\t\t}\n\t\tmoveForwardXY(delta: number, rotation2DAngle: number): void {\n\t\t\tmoveForwardXY(this, delta, rotation2DAngle);\n\t\t}\n\t\tgetPosition(): Vector | null {\n\t\t\treturn getPosition(this);\n\t\t}\n\t\tgetVelocity(): Vector | null {\n\t\t\treturn getVelocity(this);\n\t\t}\n\t\tsetPosition(x: number, y: number, z: number): void {\n\t\t\tsetPosition(this, x, y, z);\n\t\t}\n\t\tsetPositionX(x: number): void {\n\t\t\tsetPositionX(this, x);\n\t\t}\n\t\tsetPositionY(y: number): void {\n\t\t\tsetPositionY(this, y);\n\t\t}\n\t\tsetPositionZ(z: number): void {\n\t\t\tsetPositionZ(this, z);\n\t\t}\n\t\twrapAroundXY(boundsX: number, boundsY: number): void {\n\t\t\twrapAroundXY(this, boundsX, boundsY);\n\t\t}\n\t\twrapAround3D(boundsX: number, boundsY: number, boundsZ: number): void {\n\t\t\twrapAround3D(this, boundsX, boundsY, boundsZ);\n\t\t}\n\t};\n}\n\n/**\n * Enhance an entity with additive movement methods (retained for compatibility)\n */\nexport function makeMoveable<T extends EntityWithBody>(entity: T): T & MoveableEntity {\n\tconst moveable = entity as T & MoveableEntity;\n\n\tmoveable.moveX = (delta: number) => moveX(entity, delta);\n\tmoveable.moveY = (delta: number) => moveY(entity, delta);\n\tmoveable.moveZ = (delta: number) => moveZ(entity, delta);\n\tmoveable.moveXY = (deltaX: number, deltaY: number) => moveXY(entity, deltaX, deltaY);\n\tmoveable.moveXZ = (deltaX: number, deltaZ: number) => moveXZ(entity, deltaX, deltaZ);\n\tmoveable.move = (vector: Vector3) => move(entity, vector);\n\tmoveable.resetVelocity = () => resetVelocity(entity);\n\tmoveable.moveForwardXY = (delta: number, rotation2DAngle: number) => moveForwardXY(entity, delta, rotation2DAngle);\n\tmoveable.getPosition = () => getPosition(entity);\n\tmoveable.getVelocity = () => getVelocity(entity);\n\tmoveable.setPosition = (x: number, y: number, z: number) => setPosition(entity, x, y, z);\n\tmoveable.setPositionX = (x: number) => setPositionX(entity, x);\n\tmoveable.setPositionY = (y: number) => setPositionY(entity, y);\n\tmoveable.setPositionZ = (z: number) => setPositionZ(entity, z);\n\tmoveable.wrapAroundXY = (boundsX: number, boundsY: number) => wrapAroundXY(entity, boundsX, boundsY);\n\tmoveable.wrapAround3D = (boundsX: number, boundsY: number, boundsZ: number) => wrapAround3D(entity, boundsX, boundsY, boundsZ);\n\n\treturn moveable;\n}\n\n/**\n * Wrap a standalone function with movement capabilities\n */\nexport function withMovement<T extends (...args: any[]) => any>(\n\tfn: T,\n\tentity: EntityWithBody\n): (...args: Parameters<T>) => ReturnType<T> & MoveableEntity {\n\tconst wrapped = (...args: Parameters<T>) => {\n\t\tconst result = fn(...args);\n\t\tconst moveableEntity = makeMoveable(entity);\n\t\treturn Object.assign(result, moveableEntity);\n\t};\n\treturn wrapped as (...args: Parameters<T>) => ReturnType<T> & MoveableEntity;\n}","import { Euler, Vector3, MathUtils, Quaternion } from 'three';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\nexport interface RotatableEntity {\n\tbody: RigidBody | null;\n\tgroup: any;\n}\n\n/**\n * Rotate an entity in the direction of a movement vector\n */\nexport function rotateInDirection(entity: RotatableEntity, moveVector: Vector3): void {\n\tif (!entity.body) return;\n\tconst rotate = Math.atan2(-moveVector.x, moveVector.z);\n\trotateYEuler(entity, rotate);\n}\n\n/**\n * Rotate an entity around the Y axis using Euler angles\n */\nexport function rotateYEuler(entity: RotatableEntity, amount: number): void {\n\trotateEuler(entity, new Vector3(0, -amount, 0));\n}\n\n/**\n * Rotate an entity using Euler angles\n */\nexport function rotateEuler(entity: RotatableEntity, rotation: Vector3): void {\n\tif (!entity.group) return;\n\tconst euler = new Euler(rotation.x, rotation.y, rotation.z);\n\tentity.group.setRotationFromEuler(euler);\n}\n\n/**\n * Rotate an entity around the Y axis\n */\nexport function rotateY(entity: RotatableEntity, delta: number): void {\n\tsetRotationY(entity, delta);\n}\n\n/**\n * Rotate an entity around the Z axis\n */\nexport function rotateZ(entity: RotatableEntity, delta: number): void {\n\tsetRotationZ(entity, delta);\n}\n\n/**\n * Set rotation around Y axis\n */\nexport function setRotationY(entity: RotatableEntity, y: number): void {\n\tif (!entity.body) return;\n\tconst halfAngle = y / 2;\n\tconst w = Math.cos(halfAngle);\n\tconst yComponent = Math.sin(halfAngle);\n\tentity.body.setRotation({ w: w, x: 0, y: yComponent, z: 0 }, true);\n}\n\n/**\n * Set rotation around Y axis\n */\nexport function setRotationDegreesY(entity: RotatableEntity, y: number): void {\n\tif (!entity.body) return;\n\tsetRotationY(entity, MathUtils.degToRad(y));\n}\n\n/**\n * Set rotation around X axis\n */\nexport function setRotationX(entity: RotatableEntity, x: number): void {\n\tif (!entity.body) return;\n\tconst halfAngle = x / 2;\n\tconst w = Math.cos(halfAngle);\n\tconst xComponent = Math.sin(halfAngle);\n\tentity.body.setRotation({ w: w, x: xComponent, y: 0, z: 0 }, true);\n}\n\n/**\n * Set rotation around X axis\n */\nexport function setRotationDegreesX(entity: RotatableEntity, x: number): void {\n\tif (!entity.body) return;\n\tsetRotationX(entity, MathUtils.degToRad(x));\n}\n\n/**\n * Set rotation around Z axis\n */\nexport function setRotationZ(entity: RotatableEntity, z: number): void {\n\tif (!entity.body) return;\n\tconst halfAngle = z / 2;\n\tconst w = Math.cos(halfAngle);\n\tconst zComponent = Math.sin(halfAngle);\n\tentity.body.setRotation({ w: w, x: 0, y: 0, z: zComponent }, true);\n}\n\n/**\n * Set rotation around Z axis\n */\nexport function setRotationDegreesZ(entity: RotatableEntity, z: number): void {\n\tif (!entity.body) return;\n\tsetRotationZ(entity, MathUtils.degToRad(z));\n}\n\n/**\n * Set rotation for all axes\n */\nexport function setRotation(entity: RotatableEntity, x: number, y: number, z: number): void {\n\tif (!entity.body) return;\n\tconst quat = new Quaternion().setFromEuler(new Euler(x, y, z));\n\tentity.body.setRotation({ w: quat.w, x: quat.x, y: quat.y, z: quat.z }, true);\n}\n\n/**\n * Set rotation for all axes\n */\nexport function setRotationDegrees(entity: RotatableEntity, x: number, y: number, z: number): void {\n\tif (!entity.body) return;\n\tsetRotation(entity, MathUtils.degToRad(x), MathUtils.degToRad(y), MathUtils.degToRad(z));\n}\n\n/**\n * Get current rotation\n */\nexport function getRotation(entity: RotatableEntity): any {\n\tif (!entity.body) return null;\n\treturn entity.body.rotation();\n}\n\n/**\n * Rotatable entity API with bound methods\n */\nexport interface RotatableEntityAPI extends RotatableEntity {\n\trotateInDirection(moveVector: Vector3): void;\n\trotateYEuler(amount: number): void;\n\trotateEuler(rotation: Vector3): void;\n\trotateY(delta: number): void;\n\trotateZ(delta: number): void;\n\tsetRotationY(y: number): void;\n\tsetRotationX(x: number): void;\n\tsetRotationZ(z: number): void;\n\tsetRotationDegrees(x: number, y: number, z: number): void;\n\tsetRotationDegreesY(y: number): void;\n\tsetRotationDegreesX(x: number): void;\n\tsetRotationDegreesZ(z: number): void;\n\tsetRotation(x: number, y: number, z: number): void;\n\tgetRotation(): any;\n}\n\n/**\n * Class decorator to enhance an entity with rotatable methods\n */\nexport function rotatable<T extends { new(...args: any[]): RotatableEntity }>(constructor: T) {\n\treturn class extends constructor implements RotatableEntityAPI {\n\t\trotateInDirection(moveVector: Vector3): void {\n\t\t\trotateInDirection(this, moveVector);\n\t\t}\n\t\trotateYEuler(amount: number): void {\n\t\t\trotateYEuler(this, amount);\n\t\t}\n\t\trotateEuler(rotation: Vector3): void {\n\t\t\trotateEuler(this, rotation);\n\t\t}\n\t\trotateY(delta: number): void {\n\t\t\trotateY(this, delta);\n\t\t}\n\t\trotateZ(delta: number): void {\n\t\t\trotateZ(this, delta);\n\t\t}\n\t\tsetRotationY(y: number): void {\n\t\t\tsetRotationY(this, y);\n\t\t}\n\t\tsetRotationX(x: number): void {\n\t\t\tsetRotationX(this, x);\n\t\t}\n\t\tsetRotationZ(z: number): void {\n\t\t\tsetRotationZ(this, z);\n\t\t}\n\t\tsetRotationDegrees(x: number, y: number, z: number): void {\n\t\t\tsetRotationDegrees(this, x, y, z);\n\t\t}\n\t\tsetRotationDegreesY(y: number): void {\n\t\t\tsetRotationDegreesY(this, y);\n\t\t}\n\t\tsetRotationDegreesX(x: number): void {\n\t\t\tsetRotationDegreesX(this, x);\n\t\t}\n\t\tsetRotationDegreesZ(z: number): void {\n\t\t\tsetRotationDegreesZ(this, z);\n\t\t}\n\t\tsetRotation(x: number, y: number, z: number): void {\n\t\t\tsetRotation(this, x, y, z);\n\t\t}\n\t\tgetRotation(): any {\n\t\t\treturn getRotation(this);\n\t\t}\n\t};\n}\n\n/**\n * Enhance an entity instance with rotatable methods\n */\nexport function makeRotatable<T extends RotatableEntity>(entity: T): T & RotatableEntityAPI {\n\tconst rotatableEntity = entity as T & RotatableEntityAPI;\n\n\trotatableEntity.rotateInDirection = (moveVector: Vector3) => rotateInDirection(entity, moveVector);\n\trotatableEntity.rotateYEuler = (amount: number) => rotateYEuler(entity, amount);\n\trotatableEntity.rotateEuler = (rotation: Vector3) => rotateEuler(entity, rotation);\n\trotatableEntity.rotateY = (delta: number) => rotateY(entity, delta);\n\trotatableEntity.rotateZ = (delta: number) => rotateZ(entity, delta);\n\trotatableEntity.setRotationY = (y: number) => setRotationY(entity, y);\n\trotatableEntity.setRotationX = (x: number) => setRotationX(entity, x);\n\trotatableEntity.setRotationZ = (z: number) => setRotationZ(entity, z);\n\trotatableEntity.setRotationDegreesY = (y: number) => setRotationDegreesY(entity, y);\n\trotatableEntity.setRotationDegreesX = (x: number) => setRotationDegreesX(entity, x);\n\trotatableEntity.setRotationDegreesZ = (z: number) => setRotationDegreesZ(entity, z);\n\trotatableEntity.setRotationDegrees = (x: number, y: number, z: number) => setRotationDegrees(entity, x, y, z);\n\trotatableEntity.setRotation = (x: number, y: number, z: number) => setRotation(entity, x, y, z);\n\trotatableEntity.getRotation = () => getRotation(entity);\n\n\treturn rotatableEntity;\n}","import { makeMoveable, EntityWithBody, MoveableEntity } from './moveable';\nimport { makeRotatable, RotatableEntity, RotatableEntityAPI } from './rotatable';\n\n/**\n * Enhance an entity with both movement and rotation capabilities.\n */\nexport function makeTransformable<\n\tT extends RotatableEntity & EntityWithBody\n>(entity: T): T & MoveableEntity & RotatableEntityAPI {\n\tconst withMovement = makeMoveable(entity);\n\tconst withRotation = makeRotatable(withMovement);\n\treturn withRotation;\n}\n\n\n"],"mappings":"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","names":["Vector3"]}