import{d as G,e as d,G as Y,f as z,g as R,L as v,S as B,h as I,i as T,j as k,C as y,M as U,P as X,V as S,D as q,E as O,c as j}from"./game-v6-6msmH.js";import"./index-BD54UopH.js";const b={position:void 0,width:120,height:48,fillColor:"#FFFFFF",strokeColor:null,strokeWidth:0,radius:0,padding:0,stickToViewport:!0,screenPosition:new d(24,24),zDistance:1,anchor:new d(0,0)};class L extends O{createEntity(t){return new _(t)}}const $=Symbol("Rect");class _ extends Y{static type=$;_sprite=null;_mesh=null;_texture=null;_canvas=null;_ctx=null;_cameraRef=null;_lastCanvasW=0;_lastCanvasH=0;constructor(t){super(),this.options={...b,...t},this.group=new z,this.createSprite(),this.lifeCycleDelegate={setup:[this.rectSetup.bind(this)],update:[this.rectUpdate.bind(this)]}}createSprite(){this._canvas=document.createElement("canvas"),this._ctx=this._canvas.getContext("2d"),this._texture=new R(this._canvas),this._texture.minFilter=v,this._texture.magFilter=v;const t=new B({map:this._texture,transparent:!0,depthTest:!1,depthWrite:!1,alphaTest:.5});this._sprite=new I(t),this.group?.add(this._sprite),this.redrawRect()}redrawRect(){if(!this._canvas||!this._ctx)return;const t=Math.max(2,Math.floor(this.options.width??120)),e=Math.max(2,Math.floor(this.options.height??48)),s=this.options.padding??0,i=this.options.strokeWidth??0,o=t+s*2+i,r=e+s*2+i,a=Math.max(2,o),n=Math.max(2,r),h=a!==this._lastCanvasW||n!==this._lastCanvasH;this._canvas.width=a,this._canvas.height=n,this._lastCanvasW=a,this._lastCanvasH=n,this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height);const u=Math.max(0,this.options.radius??0),f=Math.floor(s+i/2),m=Math.floor(s+i/2),w=Math.floor(t),p=Math.floor(e);if(this._ctx.beginPath(),u>0?this.roundedRectPath(this._ctx,f,m,w,p,u):this._ctx.rect(f,m,w,p),this.options.fillColor&&(this._ctx.fillStyle=this.toCssColor(this.options.fillColor),this._ctx.fill()),this.options.strokeColor&&i>0&&(this._ctx.lineWidth=i,this._ctx.strokeStyle=this.toCssColor(this.options.strokeColor),this._ctx.stroke()),this._texture){if(h&&(this._texture.dispose(),this._texture=new R(this._canvas),this._texture.minFilter=v,this._texture.magFilter=v,this._texture.wrapS=T,this._texture.wrapT=T,this._sprite&&this._sprite.material instanceof k)){const c=this._sprite.material;c.uniforms?.tDiffuse&&(c.uniforms.tDiffuse.value=this._texture),c.uniforms?.iResolution&&c.uniforms.iResolution.value.set(this._canvas.width,this._canvas.height,1)}this._texture.image=this._canvas,this._texture.needsUpdate=!0,this._sprite&&this._sprite.material&&(this._sprite.material.map=this._texture,this._sprite.material.needsUpdate=!0)}}roundedRectPath(t,e,s,i,o,r){const a=Math.min(r,Math.floor(Math.min(i,o)/2));t.moveTo(e+a,s),t.lineTo(e+i-a,s),t.quadraticCurveTo(e+i,s,e+i,s+a),t.lineTo(e+i,s+o-a),t.quadraticCurveTo(e+i,s+o,e+i-a,s+o),t.lineTo(e+a,s+o),t.quadraticCurveTo(e,s+o,e,s+o-a),t.lineTo(e,s+a),t.quadraticCurveTo(e,s,e+a,s)}toCssColor(t){return typeof t=="string"?t:`#${(t instanceof y?t:new y(t)).getHexString()}`}rectSetup(t){if(this._cameraRef=t.camera,this.options.stickToViewport&&this._cameraRef&&this._cameraRef.camera.add(this.group),this.materials?.length&&this._sprite){const e=this.materials[0];e instanceof k&&(e.transparent=!0,e.depthTest=!1,e.depthWrite=!1,this._texture&&(e.uniforms?.tDiffuse&&(e.uniforms.tDiffuse.value=this._texture),e.uniforms?.iResolution&&this._canvas&&e.uniforms.iResolution.value.set(this._canvas.width,this._canvas.height,1)),this._mesh=new U(new X(1,1),e),this.group?.add(this._mesh),this._sprite.visible=!1)}}rectUpdate(t){if(this._sprite){if(this._cameraRef&&this.options.bounds){this._cameraRef.renderer.domElement;const e=this.computeScreenBoundsFromOptions(this.options.bounds);if(e){const{x:s,y:i,width:o,height:r}=e,a=Math.max(2,Math.floor(o)),n=Math.max(2,Math.floor(r)),h=a!==(this.options.width??0)||n!==(this.options.height??0);this.options.screenPosition=new d(Math.floor(s),Math.floor(i)),this.options.width=a,this.options.height=n,this.options.anchor=new d(0,0),h&&this.redrawRect()}}this.options.stickToViewport&&this._cameraRef&&this.updateStickyTransform()}}updateStickyTransform(){if(!this._sprite||!this._cameraRef)return;const t=this._cameraRef.camera,e=this._cameraRef.renderer.domElement,s=e.clientWidth,i=e.clientHeight,o=(this.options.screenPosition??new d(24,24)).x,r=(this.options.screenPosition??new d(24,24)).y,a=Math.max(.001,this.options.zDistance??1);let n=1,h=1;if(t.isPerspectiveCamera){const l=t,x=Math.tan(l.fov*Math.PI/180/2)*a;n=x*l.aspect,h=x}else if(t.isOrthographicCamera){const l=t;n=(l.right-l.left)/2,h=(l.top-l.bottom)/2}const u=o/s*2-1,f=1-r/i*2,m=u*n,w=f*h;let p=1,c=1;if(this._canvas){const x=h*2/i,M=this._canvas.height;c=Math.max(1e-4,M*x);const V=this._canvas.width/this._canvas.height;p=c*V,this._sprite.scale.set(p,c,1),this._mesh&&this._mesh.scale.set(p,c,1)}const C=this.options.anchor??new d(0,0),P=Math.min(100,Math.max(0,C.x))/100,E=Math.min(100,Math.max(0,C.y))/100,D=(.5-P)*p,F=(E-.5)*c;this.group?.position.set(m+D,w+F,-a)}worldToScreen(t){if(!this._cameraRef)return{x:0,y:0};const e=this._cameraRef.camera,s=this._cameraRef.renderer.domElement,i=t.clone().project(e),o=(i.x+1)/2*s.clientWidth,r=(1-i.y)/2*s.clientHeight;return{x:o,y:r}}computeScreenBoundsFromOptions(t){if(!this._cameraRef)return null;if(this._cameraRef.renderer.domElement,t.screen)return{...t.screen};if(t.world){const{left:e,right:s,top:i,bottom:o,z:r=0}=t.world,a=this.worldToScreen(new S(e,i,r)),n=this.worldToScreen(new S(s,o,r)),h=Math.min(a.x,n.x),u=Math.min(a.y,n.y),f=Math.abs(n.x-a.x),m=Math.abs(n.y-a.y);return{x:h,y:u,width:f,height:m}}return null}updateRect(t){this.options={...this.options,...t},this.redrawRect(),this.options.stickToViewport&&this._cameraRef&&this.updateStickyTransform()}buildInfo(){return{...new q(this).buildDebugInfo(),type:String(_.type),width:this.options.width??0,height:this.options.height??0,sticky:this.options.stickToViewport}}}async function A(...g){return G({args:g,defaultConfig:{...b},EntityClass:_,BuilderClass:L,entityType:_.type})}const H=await A({width:300,height:30,fillColor:"red",strokeColor:"black",strokeWidth:2,radius:10,padding:10,stickToViewport:!0,screenPosition:new d(20,20)});let W=300;H.onUpdate(({me:g,delta:t})=>{W+=t*10,g.updateRect({width:W,height:30,fillColor:"red",strokeColor:"black",strokeWidth:2,radius:10})});const N=j({id:"rect-test",debug:!0},H);export{N as default};
