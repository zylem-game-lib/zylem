import{b as Y,V as d,G as z,d as B,e as T,L as v,S as I,f as U,g as k,h as y,C,M as X,P as q,i as S,D as O,E as L,c as j,a as A}from"./game-CGJ5aPmk.js";import"./index-CTO3UVAX.js";const b={position:void 0,width:120,height:48,fillColor:"#FFFFFF",strokeColor:null,strokeWidth:0,radius:0,padding:0,stickToViewport:!0,screenPosition:new d(24,24),zDistance:1,anchor:new d(0,0)};class N extends L{createEntity(t){return new _(t)}}const $=Symbol("Rect");class _ extends z{static type=$;_sprite=null;_mesh=null;_texture=null;_canvas=null;_ctx=null;_cameraRef=null;_lastCanvasW=0;_lastCanvasH=0;constructor(t){super(),this.options={...b,...t},this.group=new B,this.createSprite(),this.lifeCycleDelegate={setup:[this.rectSetup.bind(this)],update:[this.rectUpdate.bind(this)]}}createSprite(){this._canvas=document.createElement("canvas"),this._ctx=this._canvas.getContext("2d"),this._texture=new T(this._canvas),this._texture.minFilter=v,this._texture.magFilter=v;const t=new I({map:this._texture,transparent:!0,depthTest:!1,depthWrite:!1,alphaTest:.5});this._sprite=new U(t),this.group?.add(this._sprite),this.redrawRect()}redrawRect(){if(!this._canvas||!this._ctx)return;const t=Math.max(2,Math.floor(this.options.width??120)),e=Math.max(2,Math.floor(this.options.height??48)),s=this.options.padding??0,i=this.options.strokeWidth??0,o=t+s*2+i,r=e+s*2+i,a=Math.max(2,o),n=Math.max(2,r),h=a!==this._lastCanvasW||n!==this._lastCanvasH;this._canvas.width=a,this._canvas.height=n,this._lastCanvasW=a,this._lastCanvasH=n,this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height);const u=Math.max(0,this.options.radius??0),f=Math.floor(s+i/2),m=Math.floor(s+i/2),w=Math.floor(t),p=Math.floor(e);if(this._ctx.beginPath(),u>0?this.roundedRectPath(this._ctx,f,m,w,p,u):this._ctx.rect(f,m,w,p),this.options.fillColor&&(this._ctx.fillStyle=this.toCssColor(this.options.fillColor),this._ctx.fill()),this.options.strokeColor&&i>0&&(this._ctx.lineWidth=i,this._ctx.strokeStyle=this.toCssColor(this.options.strokeColor),this._ctx.stroke()),this._texture){if(h&&(this._texture.dispose(),this._texture=new T(this._canvas),this._texture.minFilter=v,this._texture.magFilter=v,this._texture.wrapS=k,this._texture.wrapT=k,this._sprite&&this._sprite.material instanceof y)){const c=this._sprite.material;c.uniforms?.tDiffuse&&(c.uniforms.tDiffuse.value=this._texture),c.uniforms?.iResolution&&c.uniforms.iResolution.value.set(this._canvas.width,this._canvas.height,1)}this._texture.image=this._canvas,this._texture.needsUpdate=!0,this._sprite&&this._sprite.material&&(this._sprite.material.map=this._texture,this._sprite.material.needsUpdate=!0)}}roundedRectPath(t,e,s,i,o,r){const a=Math.min(r,Math.floor(Math.min(i,o)/2));t.moveTo(e+a,s),t.lineTo(e+i-a,s),t.quadraticCurveTo(e+i,s,e+i,s+a),t.lineTo(e+i,s+o-a),t.quadraticCurveTo(e+i,s+o,e+i-a,s+o),t.lineTo(e+a,s+o),t.quadraticCurveTo(e,s+o,e,s+o-a),t.lineTo(e,s+a),t.quadraticCurveTo(e,s,e+a,s)}toCssColor(t){return typeof t=="string"?t:`#${(t instanceof C?t:new C(t)).getHexString()}`}rectSetup(t){if(this._cameraRef=t.camera,this.options.stickToViewport&&this._cameraRef&&this._cameraRef.camera.add(this.group),this.materials?.length&&this._sprite){const e=this.materials[0];e instanceof y&&(e.transparent=!0,e.depthTest=!1,e.depthWrite=!1,this._texture&&(e.uniforms?.tDiffuse&&(e.uniforms.tDiffuse.value=this._texture),e.uniforms?.iResolution&&this._canvas&&e.uniforms.iResolution.value.set(this._canvas.width,this._canvas.height,1)),this._mesh=new X(new q(1,1),e),this.group?.add(this._mesh),this._sprite.visible=!1)}}rectUpdate(t){if(this._sprite){if(this._cameraRef&&this.options.bounds){this._cameraRef.renderer.domElement;const e=this.computeScreenBoundsFromOptions(this.options.bounds);if(e){const{x:s,y:i,width:o,height:r}=e,a=Math.max(2,Math.floor(o)),n=Math.max(2,Math.floor(r)),h=a!==(this.options.width??0)||n!==(this.options.height??0);this.options.screenPosition=new d(Math.floor(s),Math.floor(i)),this.options.width=a,this.options.height=n,this.options.anchor=new d(0,0),h&&this.redrawRect()}}this.options.stickToViewport&&this._cameraRef&&this.updateStickyTransform()}}updateStickyTransform(){if(!this._sprite||!this._cameraRef)return;const t=this._cameraRef.camera,e=this._cameraRef.renderer.domElement,s=e.clientWidth,i=e.clientHeight,o=(this.options.screenPosition??new d(24,24)).x,r=(this.options.screenPosition??new d(24,24)).y,a=Math.max(.001,this.options.zDistance??1);let n=1,h=1;if(t.isPerspectiveCamera){const l=t,x=Math.tan(l.fov*Math.PI/180/2)*a;n=x*l.aspect,h=x}else if(t.isOrthographicCamera){const l=t;n=(l.right-l.left)/2,h=(l.top-l.bottom)/2}const u=o/s*2-1,f=1-r/i*2,m=u*n,w=f*h;let p=1,c=1;if(this._canvas){const x=h*2/i,R=this._canvas.height;c=Math.max(1e-4,R*x);const G=this._canvas.width/this._canvas.height;p=c*G,this._sprite.scale.set(p,c,1),this._mesh&&this._mesh.scale.set(p,c,1)}const M=this.options.anchor??new d(0,0),P=Math.min(100,Math.max(0,M.x))/100,D=Math.min(100,Math.max(0,M.y))/100,F=(.5-P)*p,V=(D-.5)*c;this.group?.position.set(m+F,w+V,-a)}worldToScreen(t){if(!this._cameraRef)return{x:0,y:0};const e=this._cameraRef.camera,s=this._cameraRef.renderer.domElement,i=t.clone().project(e),o=(i.x+1)/2*s.clientWidth,r=(1-i.y)/2*s.clientHeight;return{x:o,y:r}}computeScreenBoundsFromOptions(t){if(!this._cameraRef)return null;if(this._cameraRef.renderer.domElement,t.screen)return{...t.screen};if(t.world){const{left:e,right:s,top:i,bottom:o,z:r=0}=t.world,a=this.worldToScreen(new S(e,i,r)),n=this.worldToScreen(new S(s,o,r)),h=Math.min(a.x,n.x),u=Math.min(a.y,n.y),f=Math.abs(n.x-a.x),m=Math.abs(n.y-a.y);return{x:h,y:u,width:f,height:m}}return null}updateRect(t){this.options={...this.options,...t},this.redrawRect(),this.options.stickToViewport&&this._cameraRef&&this.updateStickyTransform()}buildInfo(){return{...new O(this).buildDebugInfo(),type:String(_.type),width:this.options.width??0,height:this.options.height??0,sticky:this.options.stickToViewport}}}async function J(...g){return Y({args:g,defaultConfig:{...b},EntityClass:_,BuilderClass:N,entityType:_.type})}const H=await J({width:300,height:30,fillColor:"red",strokeColor:"black",strokeWidth:2,radius:10,padding:10,stickToViewport:!0,screenPosition:new d(1,1)});let W=300;H.onUpdate(({me:g,delta:t})=>{W+=t*10,g.updateRect({width:W,height:30,fillColor:"red",strokeColor:"black",strokeWidth:2,radius:10})});const E=await A({backgroundColor:new C(C.NAMES.cornsilk)});E.add(H);const Z=j({id:"rect-test",debug:!0},E);export{Z as default};
