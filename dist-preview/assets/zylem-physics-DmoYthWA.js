import{i as V,R as le,S as W,c as ve,U as me}from"./vendor-rapier-B1_KYila.js";var E={i8:"i8",ui8:"ui8",ui8c:"ui8c",i16:"i16",ui16:"ui16",i32:"i32",ui32:"ui32",f32:"f32",f64:"f64",eid:"eid"},J={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},p={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},X={uint8:2**8,uint16:2**16,uint32:2**32},he=e=>t=>Math.ceil(t/e)*e,pe=he(4),Se=Symbol("storeRef"),j=Symbol("storeSize"),be=Symbol("storeMaps"),S=Symbol("storeFlattened"),T=Symbol("storeBase"),de=Symbol("storeType"),Z=Symbol("storeArrayElementCounts"),R=Symbol("storeSubarrays"),w=Symbol("subarrayCursors"),Ee=Symbol("subarray"),z=Symbol("parentArray"),ee=Symbol("tagStore"),H=Symbol("indexType"),K=Symbol("indexBytes"),te=Symbol("isEidType"),v={},ge=(e,t)=>{if(ArrayBuffer.isView(e))e[t]=e.slice(0);else{const r=e[z].slice(0);e[t]=e.map((a,c)=>{const{length:o}=e[c],n=o*c,i=n+o;return r.subarray(n,i)})}},Ae=(e,t)=>{e[S]&&e[S].forEach(r=>{ArrayBuffer.isView(r)?r[t]=0:r[t].fill(0)})},Ce=(e,t)=>{const r=t*p[e].BYTES_PER_ELEMENT,a=new ArrayBuffer(r),c=new p[e](a);return c[te]=e===E.eid,c},$e=(e,t,r)=>{const a=e[j],c=Array(a).fill(0);c[de]=t,c[te]=t===E.eid;const o=e[w],n=r<=X.uint8?E.ui8:r<=X.uint16?E.ui16:E.ui32;if(!r)throw new Error("bitECS - Must define component array length");if(!p[t])throw new Error(`bitECS - Invalid component array property type ${t}`);if(!e[R][t]){const y=e[Z][t],f=new p[t](pe(y*a));f[H]=J[n],f[K]=p[n].BYTES_PER_ELEMENT,e[R][t]=f}const i=o[t],s=i+a*r;o[t]=s,c[z]=e[R][t].subarray(i,s);for(let y=0;y<a;y++){const f=r*y,O=f+r;c[y]=c[z].subarray(f,O),c[y][H]=J[n],c[y][K]=p[n].BYTES_PER_ELEMENT,c[y][Ee]=!0}return c},q=e=>Array.isArray(e)&&typeof e[0]=="string"&&typeof e[1]=="number",Me=(e,t)=>{const r=Symbol("store");if(!e||!Object.keys(e).length)return v[r]={[j]:t,[ee]:!0,[T]:()=>v[r]},v[r];e=JSON.parse(JSON.stringify(e));const a={},c=n=>{const i=Object.keys(n);for(const s of i)q(n[s])?(a[n[s][0]]||(a[n[s][0]]=0),a[n[s][0]]+=n[s][1]):n[s]instanceof Object&&c(n[s])};c(e);const o={[j]:t,[be]:{},[R]:{},[Se]:r,[w]:Object.keys(p).reduce((n,i)=>({...n,[i]:0}),{}),[S]:[],[Z]:a};if(e instanceof Object&&Object.keys(e).length){const n=(i,s)=>{if(typeof i[s]=="string")i[s]=Ce(i[s],t),i[s][T]=()=>v[r],o[S].push(i[s]);else if(q(i[s])){const[y,f]=i[s];i[s]=$e(o,y,f),i[s][T]=()=>v[r],o[S].push(i[s])}else i[s]instanceof Object&&(i[s]=Object.keys(i[s]).reduce(n,i[s]));return i};return v[r]=Object.assign(Object.keys(e).reduce(n,e),o),v[r][T]=()=>v[r],v[r]}},g=()=>{const e=[],t=[];e.sort=function(n){const i=Array.prototype.sort.call(this,n);for(let s=0;s<e.length;s++)t[e[s]]=s;return i};const r=n=>e[t[n]]===n;return{add:n=>{r(n)||(t[n]=e.push(n)-1)},remove:n=>{if(!r(n))return;const i=t[n],s=e.pop();s!==n&&(e[i]=s,t[s]=i)},has:r,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0}}},h=Symbol("entityMasks"),U=Symbol("entityComponents"),b=Symbol("entitySparseSet"),C=Symbol("entityArray"),Te=1e5,D=0,re=Te,k=()=>re,A=[],Re=.01,Ie=Re,Ue=()=>D,Be=new Map,Je=e=>{const t=e[Y]?A.length?A.shift():D++:A.length>Math.round(re*Ie)?A.shift():D++;if(t>e[L])throw new Error("bitECS - max entities reached");return e[b].add(t),Be.set(t,e),e[_].forEach(r=>{F(e,r,t)&&Q(r,t)}),e[U].set(t,new Set),t},Oe=(e,t)=>{if(e[b].has(t)){e[B].forEach(r=>{se(e,r,t)}),e[Y]||A.push(t),e[b].remove(t),e[U].delete(t),e[oe].delete(e[P].get(t)),e[P].delete(t);for(let r=0;r<e[h].length;r++)e[h][r][t]=0}},xe=Symbol("$modifier"),B=Symbol("queries"),_=Symbol("notQueries"),je=Symbol("queryAny"),ze=Symbol("queryAll"),De=Symbol("queryNone"),I=Symbol("queryMap"),$=Symbol("$dirtyQueries"),ne=Symbol("queryComponents"),Ne=(e,t)=>{const r=[],a=[],c=[];t[ne].forEach(u=>{if(typeof u=="function"&&u[xe]){const[l,G]=u();e[m].has(l)||N(e,l),G==="not"&&a.push(l),G==="changed"&&(c.push(l),r.push(l))}else e[m].has(u)||N(e,u),r.push(u)});const o=u=>e[m].get(u),n=r.concat(a).map(o),i=g(),s=[],y=[],f=g(),O=g(),ae=g(),ie=n.map(u=>u.generationId).reduce((u,l)=>(u.includes(l)||u.push(l),u),[]),x=(u,l)=>(u[l.generationId]||(u[l.generationId]=0),u[l.generationId]|=l.bitflag,u),ce=r.map(o).reduce(x,{}),ue=a.map(o).reduce(x,{}),ye=n.reduce(x,{}),fe=r.filter(u=>!u[ee]).map(u=>Object.getOwnPropertySymbols(u).includes(S)?u[S]:[u]).reduce((u,l)=>u.concat(l),[]),d=Object.assign(i,{archetypes:s,changed:y,components:r,notComponents:a,changedComponents:c,allComponents:n,masks:ce,notMasks:ue,hasMasks:ye,generations:ie,flatProps:fe,toRemove:f,entered:O,exited:ae,shadows:[]});e[I].set(t,d),e[B].add(d),n.forEach(u=>{u.queries.add(d)}),a.length&&e[_].add(d);for(let u=0;u<Ue();u++){if(!e[b].has(u))continue;F(e,d,u)&&Q(d,u)}},Pe=(e,t)=>{const r=Symbol(),a=e.flatProps[t];return ge(a,r),e.shadows[t]=a[r],a[r]},ke=(e,t)=>{t&&(e.changed=[]);const{flatProps:r,shadows:a}=e;for(let c=0;c<e.dense.length;c++){const o=e.dense[c];let n=!1;for(let i=0;i<r.length;i++){const s=r[i],y=a[i]||Pe(e,i);if(ArrayBuffer.isView(s[o])){for(let f=0;f<s[o].length;f++)if(s[o][f]!==y[o][f]){n=!0;break}y[o].set(s[o])}else s[o]!==y[o]&&(n=!0,y[o]=s[o])}n&&e.changed.push(o)}return e.changed},Xe=(...e)=>{let t,r,a,c;if(Array.isArray(e[0])&&(t=e[0]),t===void 0||t[m]!==void 0)return n=>n?n[C]:t[C];const o=function(n,i=!0){n[I].has(o)||Ne(n,o);const s=n[I].get(o);return Fe(n),s.changedComponents.length?ke(s,i):s.dense};return o[ne]=t,o[je]=r,o[ze]=a,o[De]=c,o},F=(e,t,r)=>{const{masks:a,notMasks:c,generations:o}=t;for(let n=0;n<o.length;n++){const i=o[n],s=a[i],y=c[i],f=e[h][i][r];if(y&&f&y||s&&(f&s)!==s)return!1}return!0},Q=(e,t)=>{e.toRemove.remove(t),e.entered.add(t),e.add(t)},_e=e=>{for(let t=e.toRemove.dense.length-1;t>=0;t--){const r=e.toRemove.dense[t];e.toRemove.remove(r),e.remove(r)}},Fe=e=>{e[$].size&&(e[$].forEach(_e),e[$].clear())},se=(e,t,r)=>{!t.has(r)||t.toRemove.has(r)||(t.toRemove.add(r),e[$].add(t),t.exited.add(r))},m=Symbol("componentMap"),He=(e,t)=>{const r=Me(e,k());return e&&Object.keys(e).length,r},Qe=e=>{e[M]*=2,e[M]>=2**31&&(e[M]=1,e[h].push(new Uint32Array(e[L])))},N=(e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");const r=new Set,a=new Set,c=new Set;e[B].forEach(o=>{o.allComponents.includes(t)&&r.add(o)}),e[m].set(t,{generationId:e[h].length-1,bitflag:e[M],store:t,queries:r,notQueries:a,changedQueries:c}),Qe(e)},Le=(e,t,r)=>{const a=e[m].get(t);if(!a)return!1;const{generationId:c,bitflag:o}=a;return(e[h][c][r]&o)===o},Ke=(e,t,r,a=!1)=>{if(r===void 0)throw new Error("bitECS - entity is undefined.");if(!e[b].has(r))throw new Error("bitECS - entity does not exist in the world.");if(e[m].has(t)||N(e,t),Le(e,t,r))return;const c=e[m].get(t),{generationId:o,bitflag:n,queries:i,notQueries:s}=c;e[h][o][r]|=n,i.forEach(y=>{y.toRemove.remove(r);const f=F(e,y,r);f&&(y.exited.remove(r),Q(y,r)),f||(y.entered.remove(r),se(e,y,r))}),e[U].get(r).add(t),a&&Ae(t,r)},L=Symbol("size"),M=Symbol("bitflag"),Ye=Symbol("archetypes"),oe=Symbol("localEntities"),P=Symbol("localEntityLookup"),Y=Symbol("manualEntityRecycling"),qe=(...e)=>{const t=typeof e[0]=="object"?e[0]:{},r=typeof e[0]=="number"?e[0]:typeof e[1]=="number"?e[1]:k();return Ge(t,r),t},Ge=(e,t=k())=>(e[L]=t,e[C]&&e[C].forEach(r=>Oe(e,r)),e[h]=[new Uint32Array(t)],e[U]=new Map,e[Ye]=[],e[b]=g(),e[C]=e[b].dense,e[M]=1,e[m]=new Map,e[I]=new Map,e[B]=new Set,e[_]=new Set,e[$]=new Set,e[oe]=new Map,e[P]=new Map,e[Y]=!1,e),Ze=e=>(t,...r)=>(e(t,...r),t),we=E;class et{static=!1;sensor=!1;gravity=new V(0,0,0);build(t){const r=this.bodyDesc({isDynamicBody:!this.static}),a=this.collider(t),{KINEMATIC_FIXED:c,DEFAULT:o}=me;return a.activeCollisionTypes=this.sensor?c:o,[r,a]}withCollision(t){return this.sensor=t?.sensor??this.sensor,this.static=t?.static??this.static,this}withPhysics(t){return this.gravity=t.gravity??this.gravity,this}collider(t){const r=t.size??new V(1,1,1),a={x:r.x/2,y:r.y/2,z:r.z/2};return le.cuboid(a.x,a.y,a.z)}bodyDesc({isDynamicBody:t=!0}){const r=t?W.Dynamic:W.Fixed;return new ve(r).setTranslation(0,0,0).setGravityScale(1).setCanSleep(!1).setCcdEnabled(!0)}}function tt(e){return typeof e?.handlePostCollision=="function"&&typeof e?.handleIntersectionEvent=="function"}export{et as C,we as T,Xe as a,Ze as b,qe as c,He as d,Je as e,Ke as f,tt as i};
