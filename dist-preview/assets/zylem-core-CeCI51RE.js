import{l as he,V as P,u as Xt,v as we,w as ie,x as Ye,T as dt,R as pe,y as Be,z as Ge,M as Le,D as zt,I as j,C as O,J as C,K as Wt,X as I,G as ue,Y as He,Z as de,n as se,o as mt,_ as Ue,i as D,$ as gt,a0 as Tt,r as At,c as yt,a1 as wt,a2 as xt,a3 as Et,a4 as qt,B as ye,F as te,a5 as Yt,a6 as Qt,a as Qe,a7 as Zt,a8 as vt,Q as V,a9 as Ve,E as Z,aa as xe,ab as je,ac as $t,ad as Ke,ae as Rt,af as z,ag as le,ah as K,ai as Jt,aj as en,ak as tn,al as Me,am as nn,an as Xe,ao as St,ap as It,aq as sn,ar as be,b as Lt,as as rn,at as on,au as an,av as cn,O as ln,aw as Mt,ax as un,ay as fn,az as hn,aA as pn,aB as dn,aC as mn,aD as gn,aE as Tn,aF as An,aG as yn}from"./vendor-three-CRJRX-3r.js";import{B as wn}from"./zylem-foundation-DJZmtUpf.js";import{s as xn,a as En,b as it}from"./zylem-state-BudcOCuz.js";import{I as vn}from"./zylem-input-DLlzDZOt.js";import{S as Rn,s as Sn}from"./zylem-stage-D0gAXhhj.js";import{G as In}from"./zylem-entities-C3wAFACT.js";class Ln{_previousTime;_currentTime;_startTime;_delta;_elapsed;_timescale;_document;_pageVisibilityHandler;constructor(){this._previousTime=0,this._currentTime=0,this._startTime=_e(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(e){this._document=e,e.hidden!==void 0&&(this._pageVisibilityHandler=Mn.bind(this),e.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){this._pageVisibilityHandler!==null&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(e){return this._timescale=e,this}reset(){return this._currentTime=_e()-this._startTime,this}dispose(){this.disconnect()}update(e){return this._pageVisibilityHandler!==null&&this._document.hidden===!0?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(e!==void 0?e:_e())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}}function _e(){return performance.now()}function Mn(){this._document.hidden===!1&&this.reset()}class Ee{id;initialGlobals={};customSetup=null;customUpdate=null;customDestroy=null;stages=[];stageMap=new Map;currentStageId="";previousTimeStamp=0;totalTime=0;timer;inputManager;wrapperRef;static FRAME_LIMIT=64;static FRAME_DURATION=1e3/Ee.FRAME_LIMIT;constructor(e,t){this.wrapperRef=t,this.inputManager=new vn,this.timer=new Ln,this.timer.connect(document),this.id=e.id,this.stages=e.stages||[],this.setGlobals(e)}async loadStage(e){const t=e.options[0];await e.load(this.id,t.camera),this.stageMap.set(e.stageRef.uuid,e),this.currentStageId=e.stageRef.uuid}setGlobals(e){xn(e.globals),En(e.debug),this.initialGlobals={...e.globals}}params(){const e=this.currentStage(),t=this.timer.getDelta(),s=this.inputManager.getInputs(t);return{delta:t,inputs:s,globals:it.globals,game:this.wrapperRef,entity:e.stageRef,camera:e.stageRef.cameraRef}}start(){const e=this.currentStage(),t=this.params();e.start(t),this.customSetup&&this.customSetup(t),this.loop(0)}loop(e){if(e-this.previousTimeStamp>=Ee.FRAME_DURATION){this.timer.update();const s=this.currentStage(),n=this.params();this.customUpdate&&this.customUpdate(n),s.stageRef.update(n),this.totalTime+=n.delta,it.time.set(this.totalTime),this.previousTimeStamp=e}requestAnimationFrame(this.loop.bind(this))}getStage(e){return this.stageMap.get(e)}currentStage(){return this.getStage(this.currentStageId)}}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var G=Uint8Array,re=Uint16Array,bn=Int32Array,bt=new G([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),_t=new G([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),_n=new G([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Ft=function(u,e){for(var t=new re(31),s=0;s<31;++s)t[s]=e+=1<<u[s-1];for(var n=new bn(t[30]),s=1;s<30;++s)for(var r=t[s];r<t[s+1];++r)n[r]=r-t[s]<<5|s;return{b:t,r:n}},Ct=Ft(bt,2),Pt=Ct.b,Fn=Ct.r;Pt[28]=258,Fn[258]=28;var Cn=Ft(_t,0),Pn=Cn.b,ze=new re(32768);for(var L=0;L<32768;++L){var q=(L&43690)>>1|(L&21845)<<1;q=(q&52428)>>2|(q&13107)<<2,q=(q&61680)>>4|(q&3855)<<4,ze[L]=((q&65280)>>8|(q&255)<<8)>>1}var fe=function(u,e,t){for(var s=u.length,n=0,r=new re(e);n<s;++n)u[n]&&++r[u[n]-1];var i=new re(e);for(n=1;n<e;++n)i[n]=i[n-1]+r[n-1]<<1;var o;if(t){o=new re(1<<e);var a=15-e;for(n=0;n<s;++n)if(u[n])for(var c=n<<4|u[n],f=e-u[n],l=i[u[n]-1]++<<f,h=l|(1<<f)-1;l<=h;++l)o[ze[l]>>a]=c}else for(o=new re(s),n=0;n<s;++n)u[n]&&(o[n]=ze[i[u[n]-1]++]>>15-u[n]);return o},ge=new G(288);for(var L=0;L<144;++L)ge[L]=8;for(var L=144;L<256;++L)ge[L]=9;for(var L=256;L<280;++L)ge[L]=7;for(var L=280;L<288;++L)ge[L]=8;var Dt=new G(32);for(var L=0;L<32;++L)Dt[L]=5;var Dn=fe(ge,9,1),On=fe(Dt,5,1),Fe=function(u){for(var e=u[0],t=1;t<u.length;++t)u[t]>e&&(e=u[t]);return e},H=function(u,e,t){var s=e/8|0;return(u[s]|u[s+1]<<8)>>(e&7)&t},Ce=function(u,e){var t=e/8|0;return(u[t]|u[t+1]<<8|u[t+2]<<16)>>(e&7)},kn=function(u){return(u+7)/8|0},Nn=function(u,e,t){return(t==null||t>u.length)&&(t=u.length),new G(u.subarray(e,t))},Bn=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],U=function(u,e,t){var s=new Error(e||Bn[u]);if(s.code=u,Error.captureStackTrace&&Error.captureStackTrace(s,U),!t)throw s;return s},Gn=function(u,e,t,s){var n=u.length,r=0;if(!n||e.f&&!e.l)return t||new G(0);var i=!t,o=i||e.i!=2,a=e.i;i&&(t=new G(n*3));var c=function(nt){var st=t.length;if(nt>st){var rt=new G(Math.max(st*2,nt));rt.set(t),t=rt}},f=e.f||0,l=e.p||0,h=e.b||0,p=e.l,d=e.d,g=e.m,m=e.n,T=n*8;do{if(!p){f=H(u,l,1);var y=H(u,l+1,3);if(l+=3,y)if(y==1)p=Dn,d=On,g=9,m=5;else if(y==2){var R=H(u,l,31)+257,S=H(u,l+10,15)+4,b=R+H(u,l+5,31)+1;l+=14;for(var F=new G(b),N=new G(19),M=0;M<S;++M)N[_n[M]]=H(u,l+M*3,7);l+=S*3;for(var $=Fe(N),ve=(1<<$)-1,Ut=fe(N,$,1),M=0;M<b;){var Ze=Ut[H(u,l,ve)];l+=Ze&15;var A=Ze>>4;if(A<16)F[M++]=A;else{var J=0,Te=0;for(A==16?(Te=3+H(u,l,3),l+=2,J=F[M-1]):A==17?(Te=3+H(u,l,7),l+=3):A==18&&(Te=11+H(u,l,127),l+=7);Te--;)F[M++]=J}}var $e=F.subarray(0,R),W=F.subarray(R);g=Fe($e),m=Fe(W),p=fe($e,g,1),d=fe(W,m,1)}else U(1);else{var A=kn(l)+4,w=u[A-4]|u[A-3]<<8,v=A+w;if(v>n){a&&U(0);break}o&&c(h+w),t.set(u.subarray(A,v),h),e.b=h+=w,e.p=l=v*8,e.f=f;continue}if(l>T){a&&U(0);break}}o&&c(h+131072);for(var Vt=(1<<g)-1,jt=(1<<m)-1,Re=l;;Re=l){var J=p[Ce(u,l)&Vt],ee=J>>4;if(l+=J&15,l>T){a&&U(0);break}if(J||U(2),ee<256)t[h++]=ee;else if(ee==256){Re=l,p=null;break}else{var Je=ee-254;if(ee>264){var M=ee-257,ae=bt[M];Je=H(u,l,(1<<ae)-1)+Pt[M],l+=ae}var Se=d[Ce(u,l)&jt],Ie=Se>>4;Se||U(3),l+=Se&15;var W=Pn[Ie];if(Ie>3){var ae=_t[Ie];W+=Ce(u,l)&(1<<ae)-1,l+=ae}if(l>T){a&&U(0);break}o&&c(h+131072);var et=h+Je;if(h<W){var tt=r-W,Kt=Math.min(W,et);for(tt+h<0&&U(3);h<Kt;++h)t[h]=s[tt+h]}for(;h<et;++h)t[h]=t[h-W]}}e.l=p,e.p=Re,e.b=h,e.f=f,p&&(f=1,e.m=g,e.d=d,e.n=m)}while(!f);return h!=t.length&&i?Nn(t,0,h):t.subarray(0,h)},Hn=new G(0),Un=function(u,e){return((u[0]&15)!=8||u[0]>>4>7||(u[0]<<8|u[1])%31)&&U(6,"invalid zlib data"),(u[1]>>5&1)==+!e&&U(6,"invalid zlib data: "+(u[1]&32?"need":"unexpected")+" dictionary"),(u[1]>>3&4)+2};function Vn(u,e){return Gn(u.subarray(Un(u,e),-4),{i:2},e,e)}var jn=typeof TextDecoder<"u"&&new TextDecoder,Kn=0;try{jn.decode(Hn,{stream:!0}),Kn=1}catch{}function Ot(u,e,t){const s=t.length-u-1;if(e>=t[s])return s-1;if(e<=t[u])return u;let n=u,r=s,i=Math.floor((n+r)/2);for(;e<t[i]||e>=t[i+1];)e<t[i]?r=i:n=i,i=Math.floor((n+r)/2);return i}function Xn(u,e,t,s){const n=[],r=[],i=[];n[0]=1;for(let o=1;o<=t;++o){r[o]=e-s[u+1-o],i[o]=s[u+o]-e;let a=0;for(let c=0;c<o;++c){const f=i[c+1],l=r[o-c],h=n[c]/(f+l);n[c]=a+f*h,a=l*h}n[o]=a}return n}function zn(u,e,t,s){const n=Ot(u,s,e),r=Xn(n,s,u,e),i=new he(0,0,0,0);for(let o=0;o<=u;++o){const a=t[n-u+o],c=r[o],f=a.w*c;i.x+=a.x*f,i.y+=a.y*f,i.z+=a.z*f,i.w+=a.w*c}return i}function Wn(u,e,t,s,n){const r=[];for(let l=0;l<=t;++l)r[l]=0;const i=[];for(let l=0;l<=s;++l)i[l]=r.slice(0);const o=[];for(let l=0;l<=t;++l)o[l]=r.slice(0);o[0][0]=1;const a=r.slice(0),c=r.slice(0);for(let l=1;l<=t;++l){a[l]=e-n[u+1-l],c[l]=n[u+l]-e;let h=0;for(let p=0;p<l;++p){const d=c[p+1],g=a[l-p];o[l][p]=d+g;const m=o[p][l-1]/o[l][p];o[p][l]=h+d*m,h=g*m}o[l][l]=h}for(let l=0;l<=t;++l)i[0][l]=o[l][t];for(let l=0;l<=t;++l){let h=0,p=1;const d=[];for(let g=0;g<=t;++g)d[g]=r.slice(0);d[0][0]=1;for(let g=1;g<=s;++g){let m=0;const T=l-g,y=t-g;l>=g&&(d[p][0]=d[h][0]/o[y+1][T],m=d[p][0]*o[T][y]);const A=T>=-1?1:-T,w=l-1<=y?g-1:t-l;for(let R=A;R<=w;++R)d[p][R]=(d[h][R]-d[h][R-1])/o[y+1][T+R],m+=d[p][R]*o[T+R][y];l<=y&&(d[p][g]=-d[h][g-1]/o[y+1][l],m+=d[p][g]*o[l][y]),i[g][l]=m;const v=h;h=p,p=v}}let f=t;for(let l=1;l<=s;++l){for(let h=0;h<=t;++h)i[l][h]*=f;f*=t-l}return i}function qn(u,e,t,s,n){const r=n<u?n:u,i=[],o=Ot(u,s,e),a=Wn(o,s,u,r,e),c=[];for(let f=0;f<t.length;++f){const l=t[f].clone(),h=l.w;l.x*=h,l.y*=h,l.z*=h,c[f]=l}for(let f=0;f<=r;++f){const l=c[o-u].clone().multiplyScalar(a[f][0]);for(let h=1;h<=u;++h)l.add(c[o-u+h].clone().multiplyScalar(a[f][h]));i[f]=l}for(let f=r+1;f<=n+1;++f)i[f]=new he(0,0,0);return i}function Yn(u,e){let t=1;for(let n=2;n<=u;++n)t*=n;let s=1;for(let n=2;n<=e;++n)s*=n;for(let n=2;n<=u-e;++n)s*=n;return t/s}function Qn(u){const e=u.length,t=[],s=[];for(let r=0;r<e;++r){const i=u[r];t[r]=new P(i.x,i.y,i.z),s[r]=i.w}const n=[];for(let r=0;r<e;++r){const i=t[r].clone();for(let o=1;o<=r;++o)i.sub(n[r-o].clone().multiplyScalar(Yn(r,o)*s[o]));n[r]=i.divideScalar(s[0])}return n}function Zn(u,e,t,s,n){const r=qn(u,e,t,s,n);return Qn(r)}class $n extends Xt{constructor(e,t,s,n,r){super();const i=t?t.length-1:0,o=s?s.length:0;this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=n||0,this.endKnot=r||i;for(let a=0;a<o;++a){const c=s[a];this.controlPoints[a]=new he(c.x,c.y,c.z,c.w)}}getPoint(e,t=new P){const s=t,n=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=zn(this.degree,this.knots,this.controlPoints,n);return r.w!==1&&r.divideScalar(r.w),s.set(r.x,r.y,r.z)}getTangent(e,t=new P){const s=t,n=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=Zn(this.degree,this.knots,this.controlPoints,n,1);return s.copy(r[1]).normalize(),s}toJSON(){const e=super.toJSON();return e.degree=this.degree,e.knots=[...this.knots],e.controlPoints=this.controlPoints.map(t=>t.toArray()),e.startKnot=this.startKnot,e.endKnot=this.endKnot,e}fromJSON(e){return super.fromJSON(e),this.degree=e.degree,this.knots=[...e.knots],this.controlPoints=e.controlPoints.map(t=>new he(t[0],t[1],t[2],t[3])),this.startKnot=e.startKnot,this.endKnot=e.endKnot,this}}let x,_,k;class Jn extends we{constructor(e){super(e)}load(e,t,s,n){const r=this,i=r.path===""?ie.extractUrlBase(e):r.path,o=new Ye(this.manager);o.setPath(r.path),o.setResponseType("arraybuffer"),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(a,i))}catch(c){n?n(c):console.error(c),r.manager.itemError(e)}},s,n)}parse(e,t){if(is(e))x=new rs().parse(e);else{const n=Bt(e);if(!os(n))throw new Error("THREE.FBXLoader: Unknown format.");if(at(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+at(n));x=new ss().parse(n)}const s=new dt(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new es(s,this.manager).parse(x)}}class es{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){_=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),s=this.parseMaterials(t),n=this.parseDeformers(),r=new ts().parse(n);return this.parseScene(n,r,s),k}parseConnections(){const e=new Map;return"Connections"in x&&x.Connections.connections.forEach(function(s){const n=s[0],r=s[1],i=s[2];e.has(n)||e.set(n,{parents:[],children:[]});const o={ID:r,relationship:i};e.get(n).parents.push(o),e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:n,relationship:i};e.get(r).children.push(a)}),e}parseImages(){const e={},t={};if("Video"in x.Objects){const s=x.Objects.Video;for(const n in s){const r=s[n],i=parseInt(n);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const o=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,a=typeof r.Content=="string"&&r.Content!=="";if(o||a){const c=this.parseImage(s[n]);t[r.RelativeFilename||r.Filename]=c}}}}for(const s in e){const n=e[s];t[n]!==void 0?e[s]=t[n]:e[s]=e[s].split("\\").pop()}return e}parseImage(e){const t=e.Content,s=e.RelativeFilename||e.Filename,n=s.slice(s.lastIndexOf(".")+1).toLowerCase();let r;switch(n){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",s),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+n+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in x.Objects){const s=x.Objects.Texture;for(const n in s){const r=this.parseTexture(s[n],e);t.set(parseInt(n),r)}}return t}parseTexture(e,t){const s=this.loadTexture(e,t);s.ID=e.id,s.name=e.attrName;const n=e.WrapModeU,r=e.WrapModeV,i=n!==void 0?n.value:0,o=r!==void 0?r.value:0;if(s.wrapS=i===0?pe:Be,s.wrapT=o===0?pe:Be,"Scaling"in e){const a=e.Scaling.value;s.repeat.x=a[0],s.repeat.y=a[1]}if("Translation"in e){const a=e.Translation.value;s.offset.x=a[0],s.offset.y=a[1]}return s}loadTexture(e,t){const s=new Set(["tga","tif","tiff","exr","dds","hdr","ktx2"]),n=e.FileName.split(".").pop().toLowerCase(),r=s.has(n)?this.manager.getHandler(`.${n}`):this.textureLoader;if(!r)return console.warn(`FBXLoader: ${n.toUpperCase()} loader not found, creating placeholder texture for`,e.RelativeFilename),new Ge;const i=r.path;i||r.setPath(this.textureLoader.path);const o=_.get(e.id).children;let a;o!==void 0&&o.length>0&&t[o[0].ID]!==void 0&&(a=t[o[0].ID],(a.indexOf("blob:")===0||a.indexOf("data:")===0)&&r.setPath(void 0));const c=r.load(a);return r.setPath(i),c}parseMaterials(e){const t=new Map;if("Material"in x.Objects){const s=x.Objects.Material;for(const n in s){const r=this.parseMaterial(s[n],e);r!==null&&t.set(parseInt(n),r)}}return t}parseMaterial(e,t){const s=e.id,n=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!_.has(s))return null;const i=this.parseParameters(e,t,s);let o;switch(r.toLowerCase()){case"phong":o=new Le;break;case"lambert":o=new zt;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),o=new Le;break}return o.setValues(i),o.name=n,o}parseParameters(e,t,s){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=j.toWorkingColorSpace(new O().fromArray(e.Diffuse.value),C):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(n.color=j.toWorkingColorSpace(new O().fromArray(e.DiffuseColor.value),C)),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=j.toWorkingColorSpace(new O().fromArray(e.Emissive.value),C):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(n.emissive=j.toWorkingColorSpace(new O().fromArray(e.EmissiveColor.value),C)),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),n.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(n.opacity===1||n.opacity===0)&&(n.opacity=e.Opacity?parseFloat(e.Opacity.value):null,n.opacity===null&&(n.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=j.toWorkingColorSpace(new O().fromArray(e.Specular.value),C):e.SpecularColor&&e.SpecularColor.type==="Color"&&(n.specular=j.toWorkingColorSpace(new O().fromArray(e.SpecularColor.value),C));const r=this;return _.get(s).children.forEach(function(i){const o=i.relationship;switch(o){case"Bump":n.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":n.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=r.getTexture(t,i.ID),n.map!==void 0&&(n.map.colorSpace=C);break;case"DisplacementColor":n.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":n.emissiveMap=r.getTexture(t,i.ID),n.emissiveMap!==void 0&&(n.emissiveMap.colorSpace=C);break;case"NormalMap":case"Maya|TEX_normal_map":n.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":n.envMap=r.getTexture(t,i.ID),n.envMap!==void 0&&(n.envMap.mapping=Wt,n.envMap.colorSpace=C);break;case"SpecularColor":n.specularMap=r.getTexture(t,i.ID),n.specularMap!==void 0&&(n.specularMap.colorSpace=C);break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=r.getTexture(t,i.ID),n.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",o);break}}),n}getTexture(e,t){return"LayeredTexture"in x.Objects&&t in x.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=_.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in x.Objects){const s=x.Objects.Deformer;for(const n in s){const r=s[n],i=_.get(parseInt(n));if(r.attrType==="Skin"){const o=this.parseSkeleton(i,s);o.ID=n,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),o.geometryID=i.parents[0].ID,e[n]=o}else if(r.attrType==="BlendShape"){const o={id:n};o.rawTargets=this.parseMorphTargets(i,s),o.id=n,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=o}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const s=[];return e.children.forEach(function(n){const r=t[n.ID];if(r.attrType!=="Cluster")return;const i={ID:n.ID,indices:[],weights:[],transformLink:new I().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),s.push(i)}),{rawBones:s,bones:[]}}parseMorphTargets(e,t){const s=[];for(let n=0;n<e.children.length;n++){const r=e.children[n],i=t[r.ID],o={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;o.geoID=_.get(parseInt(r.ID)).children.filter(function(a){return a.relationship===void 0})[0].ID,s.push(o)}return s}parseScene(e,t,s){k=new ue;const n=this.parseModels(e.skeletons,t,s),r=x.Objects.Model,i=this;n.forEach(function(a){const c=r[a.ID];i.setLookAtProperties(a,c),_.get(a.ID).parents.forEach(function(l){const h=n.get(l.ID);h!==void 0&&h.add(a)}),a.parent===null&&k.add(a)}),this.bindSkeleton(e.skeletons,t,n),this.addGlobalSceneSettings(),k.traverse(function(a){if(a.userData.transformData){a.parent&&(a.userData.transformData.parentMatrix=a.parent.matrix,a.userData.transformData.parentMatrixWorld=a.parent.matrixWorld);const c=Nt(a.userData.transformData);a.applyMatrix4(c),a.updateWorldMatrix()}});const o=new ns().parse();k.children.length===1&&k.children[0].isGroup&&(k.children[0].animations=o,k=k.children[0]),k.animations=o}parseModels(e,t,s){const n=new Map,r=x.Objects.Model;for(const i in r){const o=parseInt(i),a=r[i],c=_.get(o);let f=this.buildSkeleton(c,e,o,a.attrName);if(!f){switch(a.attrType){case"Camera":f=this.createCamera(c);break;case"Light":f=this.createLight(c);break;case"Mesh":f=this.createMesh(c,t,s);break;case"NurbsCurve":f=this.createCurve(c,t);break;case"LimbNode":case"Root":f=new He;break;case"Null":default:f=new ue;break}f.name=a.attrName?de.sanitizeNodeName(a.attrName):"",f.userData.originalName=a.attrName,f.ID=o}this.getTransformData(f,a),n.set(o,f)}return n}buildSkeleton(e,t,s,n){let r=null;return e.parents.forEach(function(i){for(const o in t){const a=t[o];a.rawBones.forEach(function(c,f){if(c.ID===i.ID){const l=r;r=new He,r.matrixWorld.copy(c.transformLink),r.name=n?de.sanitizeNodeName(n):"",r.userData.originalName=n,r.ID=s,a.bones[f]=r,l!==null&&r.add(l)}})}}),r}createCamera(e){let t,s;if(e.children.forEach(function(n){const r=x.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new se;else{let n=0;s.CameraProjectionType!==void 0&&s.CameraProjectionType.value===1&&(n=1);let r=1;s.NearPlane!==void 0&&(r=s.NearPlane.value/1e3);let i=1e3;s.FarPlane!==void 0&&(i=s.FarPlane.value/1e3);let o=window.innerWidth,a=window.innerHeight;s.AspectWidth!==void 0&&s.AspectHeight!==void 0&&(o=s.AspectWidth.value,a=s.AspectHeight.value);const c=o/a;let f=45;s.FieldOfView!==void 0&&(f=s.FieldOfView.value);const l=s.FocalLength?s.FocalLength.value:null;switch(n){case 0:t=new mt(f,c,r,i),l!==null&&t.setFocalLength(l);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new se;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),t=new se;break}}return t}createLight(e){let t,s;if(e.children.forEach(function(n){const r=x.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new se;else{let n;s.LightType===void 0?n=0:n=s.LightType.value;let r=16777215;s.Color!==void 0&&(r=j.toWorkingColorSpace(new O().fromArray(s.Color.value),C));let i=s.Intensity===void 0?1:s.Intensity.value/100;s.CastLightOnObject!==void 0&&s.CastLightOnObject.value===0&&(i=0);let o=0;s.FarAttenuationEnd!==void 0&&(s.EnableFarAttenuation!==void 0&&s.EnableFarAttenuation.value===0?o=0:o=s.FarAttenuationEnd.value);const a=1;switch(n){case 0:t=new Ue(r,i,o,a);break;case 1:t=new Tt(r,i);break;case 2:let c=Math.PI/3;s.InnerAngle!==void 0&&(c=D.degToRad(s.InnerAngle.value));let f=0;s.OuterAngle!==void 0&&(f=D.degToRad(s.OuterAngle.value),f=Math.max(f,1)),t=new gt(r,i,o,c,f,a);break;default:console.warn("THREE.FBXLoader: Unknown light type "+s.LightType.value+", defaulting to a PointLight."),t=new Ue(r,i);break}s.CastShadows!==void 0&&s.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,s){let n,r=null,i=null;const o=[];return e.children.forEach(function(a){t.has(a.ID)&&(r=t.get(a.ID)),s.has(a.ID)&&o.push(s.get(a.ID))}),o.length>1?i=o:o.length>0?i=o[0]:(i=new Le({name:we.DEFAULT_MATERIAL_NAME,color:13421772}),o.push(i)),"color"in r.attributes&&o.forEach(function(a){a.vertexColors=!0}),r.FBX_Deformer?(n=new At(r,i),n.normalizeSkinWeights()):n=new yt(r,i),n}createCurve(e,t){const s=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),n=new wt({name:we.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new xt(s,n)}getTransformData(e,t){const s={};"InheritType"in t&&(s.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?s.eulerOrder=me(t.RotationOrder.value):s.eulerOrder=me(0),"Lcl_Translation"in t&&(s.translation=t.Lcl_Translation.value),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(s.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(s.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(s.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(s.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(s.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(s.rotationPivot=t.RotationPivot.value),e.userData.transformData=s}setLookAtProperties(e,t){"LookAtProperty"in t&&_.get(e.ID).children.forEach(function(n){if(n.relationship==="LookAtProperty"){const r=x.Objects.Model[n.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),k.add(e.target)):e.lookAt(new P().fromArray(i))}}})}bindSkeleton(e,t,s){const n=this.parsePoseNodes();for(const r in e){const i=e[r];_.get(parseInt(i.ID)).parents.forEach(function(a){if(t.has(a.ID)){const c=a.ID;_.get(c).parents.forEach(function(l){s.has(l.ID)&&s.get(l.ID).bind(new Et(i.bones),n[l.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in x.Objects){const t=x.Objects.Pose;for(const s in t)if(t[s].attrType==="BindPose"&&t[s].NbPoseNodes>0){const n=t[s].PoseNode;Array.isArray(n)?n.forEach(function(r){e[r.Node]=new I().fromArray(r.Matrix.a)}):e[n.Node]=new I().fromArray(n.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in x){if("AmbientColor"in x.GlobalSettings){const e=x.GlobalSettings.AmbientColor.value,t=e[0],s=e[1],n=e[2];if(t!==0||s!==0||n!==0){const r=new O().setRGB(t,s,n,C);k.add(new qt(r,1))}}"UnitScaleFactor"in x.GlobalSettings&&(k.userData.unitScaleFactor=x.GlobalSettings.UnitScaleFactor.value)}}}class ts{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in x.Objects){const s=x.Objects.Geometry;for(const n in s){const r=_.get(parseInt(n)),i=this.parseGeometry(r,s[n],e);t.set(parseInt(n),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,s){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,s);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,s){const n=s.skeletons,r=[],i=e.parents.map(function(l){return x.Objects.Model[l.ID]});if(i.length===0)return;const o=e.children.reduce(function(l,h){return n[h.ID]!==void 0&&(l=n[h.ID]),l},null);e.children.forEach(function(l){s.morphTargets[l.ID]!==void 0&&r.push(s.morphTargets[l.ID])});const a=i[0],c={};"RotationOrder"in a&&(c.eulerOrder=me(a.RotationOrder.value)),"InheritType"in a&&(c.inheritType=parseInt(a.InheritType.value)),"GeometricTranslation"in a&&(c.translation=a.GeometricTranslation.value),"GeometricRotation"in a&&(c.rotation=a.GeometricRotation.value),"GeometricScaling"in a&&(c.scale=a.GeometricScaling.value);const f=Nt(c);return this.genGeometry(t,o,r,f)}genGeometry(e,t,s,n){const r=new ye;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),o=this.genBuffers(i),a=new te(o.vertex,3);if(a.applyMatrix4(n),r.setAttribute("position",a),o.colors.length>0&&r.setAttribute("color",new te(o.colors,3)),t&&(r.setAttribute("skinIndex",new Yt(o.weightsIndices,4)),r.setAttribute("skinWeight",new te(o.vertexWeights,4)),r.FBX_Deformer=t),o.normal.length>0){const c=new Qt().getNormalMatrix(n),f=new te(o.normal,3);f.applyNormalMatrix(c),r.setAttribute("normal",f)}if(o.uvs.forEach(function(c,f){const l=f===0?"uv":`uv${f}`;r.setAttribute(l,new te(o.uvs[f],2))}),i.material&&i.material.mappingType!=="AllSame"){let c=o.materialIndex[0],f=0;if(o.materialIndex.forEach(function(l,h){l!==c&&(r.addGroup(f,h-f,c),c=l,f=h)}),r.groups.length>0){const l=r.groups[r.groups.length-1],h=l.start+l.count;h!==o.materialIndex.length&&r.addGroup(h,o.materialIndex.length-h,c)}r.groups.length===0&&r.addGroup(0,o.materialIndex.length,o.materialIndex[0])}return this.addMorphTargets(r,e,s,n),r}parseGeoNode(e,t){const s={};if(s.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],s.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(s.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(s.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(s.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){s.uv=[];let n=0;for(;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&s.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return s.weightTable={},t!==null&&(s.skeleton=t,t.rawBones.forEach(function(n,r){n.indices.forEach(function(i,o){s.weightTable[i]===void 0&&(s.weightTable[i]=[]),s.weightTable[i].push({id:r,weight:n.weights[o]})})})),s}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let s=0,n=0,r=!1,i=[],o=[],a=[],c=[],f=[],l=[];const h=this;return e.vertexIndices.forEach(function(p,d){let g,m=!1;p<0&&(p=p^-1,m=!0);let T=[],y=[];if(i.push(p*3,p*3+1,p*3+2),e.color){const A=Ae(d,s,p,e.color);a.push(A[0],A[1],A[2])}if(e.skeleton){if(e.weightTable[p]!==void 0&&e.weightTable[p].forEach(function(A){y.push(A.weight),T.push(A.id)}),y.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const A=[0,0,0,0],w=[0,0,0,0];y.forEach(function(v,R){let S=v,b=T[R];w.forEach(function(F,N,M){if(S>F){M[N]=S,S=F;const $=A[N];A[N]=b,b=$}})}),T=A,y=w}for(;y.length<4;)y.push(0),T.push(0);for(let A=0;A<4;++A)f.push(y[A]),l.push(T[A])}if(e.normal){const A=Ae(d,s,p,e.normal);o.push(A[0],A[1],A[2])}e.material&&e.material.mappingType!=="AllSame"&&(g=Ae(d,s,p,e.material)[0],g<0&&(h.negativeMaterialIndices=!0,g=0)),e.uv&&e.uv.forEach(function(A,w){const v=Ae(d,s,p,A);c[w]===void 0&&(c[w]=[]),c[w].push(v[0]),c[w].push(v[1])}),n++,m&&(h.genFace(t,e,i,g,o,a,c,f,l,n),s++,n=0,i=[],o=[],a=[],c=[],f=[],l=[])}),t}getNormalNewell(e){const t=new P(0,0,0);for(let s=0;s<e.length;s++){const n=e[s],r=e[(s+1)%e.length];t.x+=(n.y-r.y)*(n.z+r.z),t.y+=(n.z-r.z)*(n.x+r.x),t.z+=(n.x-r.x)*(n.y+r.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),n=(Math.abs(t.z)>.5?new P(0,1,0):new P(0,0,1)).cross(t).normalize(),r=t.clone().cross(n).normalize();return{normal:t,tangent:n,bitangent:r}}flattenVertex(e,t,s){return new Qe(e.dot(t),e.dot(s))}genFace(e,t,s,n,r,i,o,a,c,f){let l;if(f>3){const h=[],p=t.baseVertexPositions||t.vertexPositions;for(let T=0;T<s.length;T+=3)h.push(new P(p[s[T]],p[s[T+1]],p[s[T+2]]));const{tangent:d,bitangent:g}=this.getNormalTangentAndBitangent(h),m=[];for(const T of h)m.push(this.flattenVertex(T,d,g));l=Zt.triangulateShape(m,[])}else l=[[0,1,2]];for(const[h,p,d]of l)e.vertex.push(t.vertexPositions[s[h*3]]),e.vertex.push(t.vertexPositions[s[h*3+1]]),e.vertex.push(t.vertexPositions[s[h*3+2]]),e.vertex.push(t.vertexPositions[s[p*3]]),e.vertex.push(t.vertexPositions[s[p*3+1]]),e.vertex.push(t.vertexPositions[s[p*3+2]]),e.vertex.push(t.vertexPositions[s[d*3]]),e.vertex.push(t.vertexPositions[s[d*3+1]]),e.vertex.push(t.vertexPositions[s[d*3+2]]),t.skeleton&&(e.vertexWeights.push(a[h*4]),e.vertexWeights.push(a[h*4+1]),e.vertexWeights.push(a[h*4+2]),e.vertexWeights.push(a[h*4+3]),e.vertexWeights.push(a[p*4]),e.vertexWeights.push(a[p*4+1]),e.vertexWeights.push(a[p*4+2]),e.vertexWeights.push(a[p*4+3]),e.vertexWeights.push(a[d*4]),e.vertexWeights.push(a[d*4+1]),e.vertexWeights.push(a[d*4+2]),e.vertexWeights.push(a[d*4+3]),e.weightsIndices.push(c[h*4]),e.weightsIndices.push(c[h*4+1]),e.weightsIndices.push(c[h*4+2]),e.weightsIndices.push(c[h*4+3]),e.weightsIndices.push(c[p*4]),e.weightsIndices.push(c[p*4+1]),e.weightsIndices.push(c[p*4+2]),e.weightsIndices.push(c[p*4+3]),e.weightsIndices.push(c[d*4]),e.weightsIndices.push(c[d*4+1]),e.weightsIndices.push(c[d*4+2]),e.weightsIndices.push(c[d*4+3])),t.color&&(e.colors.push(i[h*3]),e.colors.push(i[h*3+1]),e.colors.push(i[h*3+2]),e.colors.push(i[p*3]),e.colors.push(i[p*3+1]),e.colors.push(i[p*3+2]),e.colors.push(i[d*3]),e.colors.push(i[d*3+1]),e.colors.push(i[d*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(r[h*3]),e.normal.push(r[h*3+1]),e.normal.push(r[h*3+2]),e.normal.push(r[p*3]),e.normal.push(r[p*3+1]),e.normal.push(r[p*3+2]),e.normal.push(r[d*3]),e.normal.push(r[d*3+1]),e.normal.push(r[d*3+2])),t.uv&&t.uv.forEach(function(g,m){e.uvs[m]===void 0&&(e.uvs[m]=[]),e.uvs[m].push(o[m][h*2]),e.uvs[m].push(o[m][h*2+1]),e.uvs[m].push(o[m][p*2]),e.uvs[m].push(o[m][p*2+1]),e.uvs[m].push(o[m][d*2]),e.uvs[m].push(o[m][d*2+1])})}addMorphTargets(e,t,s,n){if(s.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;s.forEach(function(i){i.rawTargets.forEach(function(o){const a=x.Objects.Geometry[o.geoID];a!==void 0&&r.genMorphGeometry(e,t,a,n,o.name)})})}genMorphGeometry(e,t,s,n,r){const i=t.Vertices!==void 0?t.Vertices.a:[],o=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=s.Vertices!==void 0?s.Vertices.a:[],c=s.Indexes!==void 0?s.Indexes.a:[],f=e.attributes.position.count*3,l=new Float32Array(f);for(let g=0;g<c.length;g++){const m=c[g]*3;l[m]=a[g*3],l[m+1]=a[g*3+1],l[m+2]=a[g*3+2]}const h={vertexIndices:o,vertexPositions:l,baseVertexPositions:i},p=this.genBuffers(h),d=new te(p.vertex,3);d.name=r||s.attrName,d.applyMatrix4(n),e.morphAttributes.position.push(d)}parseNormals(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Normals.a;let r=[];return s==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:r,mappingType:t,referenceType:s}}parseUVs(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.UV.a;let r=[];return s==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:n,indices:r,mappingType:t,referenceType:s}}parseVertexColors(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Colors.a;let r=[];s==="IndexToDirect"&&(r=e.ColorIndex.a);for(let i=0,o=new O;i<n.length;i+=4)o.fromArray(n,i),j.toWorkingColorSpace(o,C),o.toArray(n,i);return{dataSize:4,buffer:n,indices:r,mappingType:t,referenceType:s}}parseMaterialIndices(e){const t=e.MappingInformationType,s=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:s};const n=e.Materials.a,r=[];for(let i=0;i<n.length;++i)r.push(i);return{dataSize:1,buffer:n,indices:r,mappingType:t,referenceType:s}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new ye;const s=t-1,n=e.KnotVector.a,r=[],i=e.Points.a;for(let l=0,h=i.length;l<h;l+=4)r.push(new he().fromArray(i,l));let o,a;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){o=s,a=n.length-1-o;for(let l=0;l<s;++l)r.push(r[l])}const f=new $n(s,n,r,o,a).getPoints(r.length*12);return new ye().setFromPoints(f)}}class ns{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const s in t){const n=t[s],r=this.addClip(n);e.push(r)}return e}parseClips(){if(x.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=x.Objects.AnimationCurveNode,t=new Map;for(const s in e){const n=e[s];if(n.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:n.id,attr:n.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=x.Objects.AnimationCurve;for(const s in t){const n={id:t[s].id,times:t[s].KeyTime.a.map(as),values:t[s].KeyValueFloat.a},r=_.get(n.id);if(r!==void 0){const i=r.parents[0].ID,o=r.parents[0].relationship;o.match(/X/)?e.get(i).curves.x=n:o.match(/Y/)?e.get(i).curves.y=n:o.match(/Z/)?e.get(i).curves.z=n:o.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=n)}}}parseAnimationLayers(e){const t=x.Objects.AnimationLayer,s=new Map;for(const n in t){const r=[],i=_.get(parseInt(n));i!==void 0&&(i.children.forEach(function(a,c){if(e.has(a.ID)){const f=e.get(a.ID);if(f.curves.x!==void 0||f.curves.y!==void 0||f.curves.z!==void 0){if(r[c]===void 0){const l=_.get(a.ID).parents.filter(function(h){return h.relationship!==void 0})[0].ID;if(l!==void 0){const h=x.Objects.Model[l.toString()];if(h===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",a);return}const p={modelName:h.attrName?de.sanitizeNodeName(h.attrName):"",ID:h.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};k.traverse(function(d){d.ID===h.id&&(p.transform=d.matrix,d.userData.transformData&&(p.eulerOrder=d.userData.transformData.eulerOrder))}),p.transform||(p.transform=new I),"PreRotation"in h&&(p.preRotation=h.PreRotation.value),"PostRotation"in h&&(p.postRotation=h.PostRotation.value),r[c]=p}}r[c]&&(r[c][f.attr]=f)}else if(f.curves.morph!==void 0){if(r[c]===void 0){const l=_.get(a.ID).parents.filter(function(T){return T.relationship!==void 0})[0].ID,h=_.get(l).parents[0].ID,p=_.get(h).parents[0].ID,d=_.get(p).parents[0].ID,g=x.Objects.Model[d],m={modelName:g.attrName?de.sanitizeNodeName(g.attrName):"",morphName:x.Objects.Deformer[l].attrName};r[c]=m}r[c][f.attr]=f}}}),s.set(parseInt(n),r))}return s}parseAnimStacks(e){const t=x.Objects.AnimationStack,s={};for(const n in t){const r=_.get(parseInt(n)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);s[n]={name:t[n].attrName,layer:i}}return s}addClip(e){let t=[];const s=this;return e.layer.forEach(function(n){t=t.concat(s.generateTracks(n))}),new vt(e.name,-1,t)}generateTracks(e){const t=[];let s=new P,n=new P;if(e.transform&&e.transform.decompose(s,new V,n),s=s.toArray(),n=n.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,s,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,s,n){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,s);return new Ve(e+"."+n,r,i)}generateRotationTrack(e,t,s,n,r){let i,o;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const h=this.interpolateRotations(t.x,t.y,t.z,r);i=h[0],o=h[1]}const a=me(0);s!==void 0&&(s=s.map(D.degToRad),s.push(a),s=new Z().fromArray(s),s=new V().setFromEuler(s)),n!==void 0&&(n=n.map(D.degToRad),n.push(a),n=new Z().fromArray(n),n=new V().setFromEuler(n).invert());const c=new V,f=new Z,l=[];if(!o||!i)return new xe(e+".quaternion",[0],[0]);for(let h=0;h<o.length;h+=3)f.set(o[h],o[h+1],o[h+2],r),c.setFromEuler(f),s!==void 0&&c.premultiply(s),n!==void 0&&c.multiply(n),h>2&&new V().fromArray(l,(h-3)/3*4).dot(c)<0&&c.set(-c.x,-c.y,-c.z,-c.w),c.toArray(l,h/3*4);return new xe(e+".quaternion",i,l)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,s=t.values.map(function(r){return r/100}),n=k.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new je(e.modelName+".morphTargetInfluences["+n+"]",t.times,s)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(s,n){return s-n}),t.length>1){let s=1,n=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==n&&(t[s]=i,n=i,s++)}t=t.slice(0,s)}return t}getKeyframeTrackValues(e,t,s){const n=s,r=[];let i=-1,o=-1,a=-1;return e.forEach(function(c){if(t.x&&(i=t.x.times.indexOf(c)),t.y&&(o=t.y.times.indexOf(c)),t.z&&(a=t.z.times.indexOf(c)),i!==-1){const f=t.x.values[i];r.push(f),n[0]=f}else r.push(n[0]);if(o!==-1){const f=t.y.values[o];r.push(f),n[1]=f}else r.push(n[1]);if(a!==-1){const f=t.z.values[a];r.push(f),n[2]=f}else r.push(n[2])}),r}interpolateRotations(e,t,s,n){const r=[],i=[];r.push(e.times[0]),i.push(D.degToRad(e.values[0])),i.push(D.degToRad(t.values[0])),i.push(D.degToRad(s.values[0]));for(let o=1;o<e.values.length;o++){const a=[e.values[o-1],t.values[o-1],s.values[o-1]];if(isNaN(a[0])||isNaN(a[1])||isNaN(a[2]))continue;const c=a.map(D.degToRad),f=[e.values[o],t.values[o],s.values[o]];if(isNaN(f[0])||isNaN(f[1])||isNaN(f[2]))continue;const l=f.map(D.degToRad),h=[f[0]-a[0],f[1]-a[1],f[2]-a[2]],p=[Math.abs(h[0]),Math.abs(h[1]),Math.abs(h[2])];if(p[0]>=180||p[1]>=180||p[2]>=180){const g=Math.max(...p)/180,m=new Z(...c,n),T=new Z(...l,n),y=new V().setFromEuler(m),A=new V().setFromEuler(T);y.dot(A)&&A.set(-A.x,-A.y,-A.z,-A.w);const w=e.times[o-1],v=e.times[o]-w,R=new V,S=new Z;for(let b=0;b<1;b+=1/g)R.copy(y.clone().slerp(A.clone(),b)),r.push(w+b*v),S.setFromQuaternion(R,n),i.push(S.x),i.push(S.y),i.push(S.z)}else r.push(e.times[o]),i.push(D.degToRad(e.values[o])),i.push(D.degToRad(t.values[o])),i.push(D.degToRad(s.values[o]))}return[r,i]}}class ss{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new kt,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,s=e.split(/[\r\n]+/);return s.forEach(function(n,r){const i=n.match(/^[\s\t]*;/),o=n.match(/^[\s\t]*$/);if(i||o)return;const a=n.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=n.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),f=n.match("^\\t{"+(t.currentIndent-1)+"}}");a?t.parseNodeBegin(n,a):c?t.parseNodeProperty(n,c,s[++r]):f?t.popStack():n.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(e,t){const s=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map(function(a){return a.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:s},i=this.parseNodeAttr(n),o=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(s,r):s in o?(s==="PoseNode"?o.PoseNode.push(r):o[s].id!==void 0&&(o[s]={},o[s][o[s].id]=o[s]),i.id!==""&&(o[s][i.id]=r)):typeof i.id=="number"?(o[s]={},o[s][i.id]=r):s!=="Properties70"&&(s==="PoseNode"?o[s]=[r]:o[s]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let s="",n="";return e.length>1&&(s=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:s,type:n}}parseNodeProperty(e,t,s){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();n==="Content"&&r===","&&(r=s.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,n,r);return}if(n==="C"){const a=r.split(",").slice(1),c=parseInt(a[0]),f=parseInt(a[1]);let l=r.split(",").slice(3);l=l.map(function(h){return h.trim().replace(/^"/,"")}),n="connections",r=[c,f],ls(r,l),i[n]===void 0&&(i[n]=[])}n==="Node"&&(i.id=r),n in i&&Array.isArray(i[n])?i[n].push(r):n!=="a"?i[n]=r:i.a=r,this.setCurrentProp(i,n),n==="a"&&r.slice(-1)!==","&&(i.a=De(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=De(t.a))}parseNodeSpecialProperty(e,t,s){const n=s.split('",').map(function(f){return f.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=n[0],i=n[1],o=n[2],a=n[3];let c=n[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=De(c);break}this.getPrevNode()[r]={type:i,type2:o,flag:a,value:c},this.setCurrentProp(this.getPrevNode(),r)}}class rs{parse(e){const t=new ot(e);t.skip(23);const s=t.getUint32();if(s<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+s);const n=new kt;for(;!this.endOfContent(t);){const r=this.parseNode(t,s);r!==null&&n.add(r.name,r)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const s={},n=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),o=e.getString(i);if(n===0)return null;const a=[];for(let h=0;h<r;h++)a.push(this.parseProperty(e));const c=a.length>0?a[0]:"",f=a.length>1?a[1]:"",l=a.length>2?a[2]:"";for(s.singleProperty=r===1&&e.getOffset()===n;n>e.getOffset();){const h=this.parseNode(e,t);h!==null&&this.parseSubNode(o,s,h)}return s.propertyList=a,typeof c=="number"&&(s.id=c),f!==""&&(s.attrName=f),l!==""&&(s.attrType=l),o!==""&&(s.name=o),s}parseSubNode(e,t,s){if(s.singleProperty===!0){const n=s.propertyList[0];Array.isArray(n)?(t[s.name]=s,s.a=n):t[s.name]=n}else if(e==="Connections"&&s.name==="C"){const n=[];s.propertyList.forEach(function(r,i){i!==0&&n.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(n)}else if(s.name==="Properties70")Object.keys(s).forEach(function(r){t[r]=s[r]});else if(e==="Properties70"&&s.name==="P"){let n=s.propertyList[0],r=s.propertyList[1];const i=s.propertyList[2],o=s.propertyList[3];let a;n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?a=[s.propertyList[4],s.propertyList[5],s.propertyList[6]]:a=s.propertyList[4],t[n]={type:r,type2:i,flag:o,value:a}}else t[s.name]===void 0?typeof s.id=="number"?(t[s.name]={},t[s.name][s.id]=s):t[s.name]=s:s.name==="PoseNode"?(Array.isArray(t[s.name])||(t[s.name]=[t[s.name]]),t[s.name].push(s)):t[s.name][s.id]===void 0&&(t[s.name][s.id]=s)}parseProperty(e){const t=e.getString(1);let s;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return s=e.getUint32(),e.getArrayBuffer(s);case"S":return s=e.getUint32(),e.getString(s);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const o=Vn(new Uint8Array(e.getArrayBuffer(i))),a=new ot(o.buffer);switch(t){case"b":case"c":return a.getBooleanArray(n);case"d":return a.getFloat64Array(n);case"f":return a.getFloat32Array(n);case"i":return a.getInt32Array(n);case"l":return a.getInt64Array(n)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class ot{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let s=0;s<e;s++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let s=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const n=s.indexOf(0);return n>=0&&(s=new Uint8Array(this.dv.buffer,t,n)),this._textDecoder.decode(s)}}class kt{add(e,t){this[e]=t}}function is(u){const e="Kaydara FBX Binary  \0";return u.byteLength>=e.length&&e===Bt(u,0,e.length)}function os(u){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function s(n){const r=u[n-1];return u=u.slice(t+n),t++,r}for(let n=0;n<e.length;++n)if(s(1)===e[n])return!1;return!0}function at(u){const e=/FBXVersion: (\d+)/,t=u.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function as(u){return u/46186158e3}const cs=[];function Ae(u,e,t,s){let n;switch(s.mappingType){case"ByPolygonVertex":n=u;break;case"ByPolygon":n=e;break;case"ByVertice":n=t;break;case"AllSame":n=s.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+s.mappingType)}s.referenceType==="IndexToDirect"&&(n=s.indices[n]);const r=n*s.dataSize,i=r+s.dataSize;return us(cs,s.buffer,r,i)}const Pe=new Z,ne=new P;function Nt(u){const e=new I,t=new I,s=new I,n=new I,r=new I,i=new I,o=new I,a=new I,c=new I,f=new I,l=new I,h=new I,p=u.inheritType?u.inheritType:0;u.translation&&e.setPosition(ne.fromArray(u.translation));const d=me(0);if(u.preRotation){const M=u.preRotation.map(D.degToRad);M.push(d),t.makeRotationFromEuler(Pe.fromArray(M))}if(u.rotation){const M=u.rotation.map(D.degToRad);M.push(u.eulerOrder||d),s.makeRotationFromEuler(Pe.fromArray(M))}if(u.postRotation){const M=u.postRotation.map(D.degToRad);M.push(d),n.makeRotationFromEuler(Pe.fromArray(M)),n.invert()}u.scale&&r.scale(ne.fromArray(u.scale)),u.scalingOffset&&o.setPosition(ne.fromArray(u.scalingOffset)),u.scalingPivot&&i.setPosition(ne.fromArray(u.scalingPivot)),u.rotationOffset&&a.setPosition(ne.fromArray(u.rotationOffset)),u.rotationPivot&&c.setPosition(ne.fromArray(u.rotationPivot)),u.parentMatrixWorld&&(l.copy(u.parentMatrix),f.copy(u.parentMatrixWorld));const g=t.clone().multiply(s).multiply(n),m=new I;m.extractRotation(f);const T=new I;T.copyPosition(f);const y=T.clone().invert().multiply(f),A=m.clone().invert().multiply(y),w=r,v=new I;if(p===0)v.copy(m).multiply(g).multiply(A).multiply(w);else if(p===1)v.copy(m).multiply(A).multiply(g).multiply(w);else{const $=new I().scale(new P().setFromMatrixScale(l)).clone().invert(),ve=A.clone().multiply($);v.copy(m).multiply(g).multiply(ve).multiply(w)}const R=c.clone().invert(),S=i.clone().invert();let b=e.clone().multiply(a).multiply(c).multiply(t).multiply(s).multiply(n).multiply(R).multiply(o).multiply(i).multiply(r).multiply(S);const F=new I().copyPosition(b),N=f.clone().multiply(F);return h.copyPosition(N),b=h.clone().multiply(v),b.premultiply(f.invert()),b}function me(u){u=u||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return u===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[u]}function De(u){return u.split(",").map(function(t){return parseFloat(t)})}function Bt(u,e,t){return e===void 0&&(e=0),t===void 0&&(t=u.byteLength),new TextDecoder().decode(new Uint8Array(u,e,t))}function ls(u,e){for(let t=0,s=u.length,n=e.length;t<n;t++,s++)u[s]=e[t]}function us(u,e,t,s){for(let n=t,r=0;n<s;n++,r++)u[r]=e[n];return u}function ct(u,e){if(e===$t)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),u;if(e===Ke||e===Rt){let t=u.getIndex();if(t===null){const i=[],o=u.getAttribute("position");if(o!==void 0){for(let a=0;a<o.count;a++)i.push(a);u.setIndex(i),t=u.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),u}const s=t.count-2,n=[];if(e===Ke)for(let i=1;i<=s;i++)n.push(t.getX(0)),n.push(t.getX(i)),n.push(t.getX(i+1));else for(let i=0;i<s;i++)i%2===0?(n.push(t.getX(i)),n.push(t.getX(i+1)),n.push(t.getX(i+2))):(n.push(t.getX(i+2)),n.push(t.getX(i+1)),n.push(t.getX(i)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=u.clone();return r.setIndex(n),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),u}class fs extends we{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new gs(t)}),this.register(function(t){return new Ts(t)}),this.register(function(t){return new Is(t)}),this.register(function(t){return new Ls(t)}),this.register(function(t){return new Ms(t)}),this.register(function(t){return new ys(t)}),this.register(function(t){return new ws(t)}),this.register(function(t){return new xs(t)}),this.register(function(t){return new Es(t)}),this.register(function(t){return new ms(t)}),this.register(function(t){return new vs(t)}),this.register(function(t){return new As(t)}),this.register(function(t){return new Ss(t)}),this.register(function(t){return new Rs(t)}),this.register(function(t){return new ps(t)}),this.register(function(t){return new bs(t)}),this.register(function(t){return new _s(t)})}load(e,t,s,n){const r=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const c=ie.extractUrlBase(e);i=ie.resolveURL(c,this.path)}else i=ie.extractUrlBase(e);this.manager.itemStart(e);const o=function(c){n?n(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},a=new Ye(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(c){try{r.parse(c,i,function(f){t(f),r.manager.itemEnd(e)},o)}catch(f){o(f)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let r;const i={},o={},a=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(a.decode(new Uint8Array(e,0,4))===Gt){try{i[E.KHR_BINARY_GLTF]=new Fs(e)}catch(l){n&&n(l);return}r=JSON.parse(i[E.KHR_BINARY_GLTF].content)}else r=JSON.parse(a.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Ks(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let f=0;f<this.pluginCallbacks.length;f++){const l=this.pluginCallbacks[f](c);l.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[l.name]=l,i[l.name]=!0}if(r.extensionsUsed)for(let f=0;f<r.extensionsUsed.length;++f){const l=r.extensionsUsed[f],h=r.extensionsRequired||[];switch(l){case E.KHR_MATERIALS_UNLIT:i[l]=new ds;break;case E.KHR_DRACO_MESH_COMPRESSION:i[l]=new Cs(r,this.dracoLoader);break;case E.KHR_TEXTURE_TRANSFORM:i[l]=new Ps;break;case E.KHR_MESH_QUANTIZATION:i[l]=new Ds;break;default:h.indexOf(l)>=0&&o[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(i),c.setPlugins(o),c.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,t,n,r)})}}function hs(){let u={};return{get:function(e){return u[e]},add:function(e,t){u[e]=t},remove:function(e){delete u[e]},removeAll:function(){u={}}}}const E={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class ps{constructor(e){this.parser=e,this.name=E.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const r=t.json,a=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let c;const f=new O(16777215);a.color!==void 0&&f.setRGB(a.color[0],a.color[1],a.color[2],z);const l=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new Tt(f),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Ue(f),c.distance=l;break;case"spot":c=new gt(f),c.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,X(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=t.createUniqueName(a.name||"light_"+e),n=Promise.resolve(c),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(a){return s._getNodeRef(t.cache,o,a)})}}class ds{constructor(){this.name=E.KHR_MATERIALS_UNLIT}getMaterialType(){return le}extendParams(e,t,s){const n=[];e.color=new O(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.setRGB(i[0],i[1],i[2],z),e.opacity=i[3]}r.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",r.baseColorTexture,C))}return Promise.all(n)}}class ms{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class gs{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const o=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Qe(o,o)}return Promise.all(r)}}class Ts{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class As{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class ys{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new O(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=n.extensions[this.name];if(i.sheenColorFactor!==void 0){const o=i.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],z)}return i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",i.sheenColorTexture,C)),i.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class ws{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class xs{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const o=i.attenuationColor||[1,1,1];return t.attenuationColor=new O().setRGB(o[0],o[1],o[2],z),Promise.all(r)}}class Es{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class vs{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",i.specularTexture));const o=i.specularColorFactor||[1,1,1];return t.specularColor=new O().setRGB(o[0],o[1],o[2],z),i.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",i.specularColorTexture,C)),Promise.all(r)}}class Rs{constructor(e){this.parser=e,this.name=E.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return t.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&r.push(s.assignTexture(t,"bumpMap",i.bumpTexture)),Promise.all(r)}}class Ss{constructor(e){this.parser=e,this.name=E.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:K}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class Is{constructor(e){this.parser=e,this.name=E.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class Ls{constructor(e){this.parser=e,this.name=E.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],o=n.images[i.source];let a=s.textureLoader;if(o.uri){const c=s.options.manager.getHandler(o.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,i.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Ms{constructor(e){this.parser=e,this.name=E.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],o=n.images[i.source];let a=s.textureLoader;if(o.uri){const c=s.options.manager.getHandler(o.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,i.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class bs{constructor(e){this.name=E.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(o){const a=n.byteOffset||0,c=n.byteLength||0,f=n.count,l=n.byteStride,h=new Uint8Array(o,a,c);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(f,l,h,n.mode,n.filter).then(function(p){return p.buffer}):i.ready.then(function(){const p=new ArrayBuffer(f*l);return i.decodeGltfBuffer(new Uint8Array(p),f,l,h,n.mode,n.filter),p})})}else return null}}class _s{constructor(e){this.name=E.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const c of n.primitives)if(c.mode!==B.TRIANGLES&&c.mode!==B.TRIANGLE_STRIP&&c.mode!==B.TRIANGLE_FAN&&c.mode!==void 0)return null;const i=s.extensions[this.name].attributes,o=[],a={};for(const c in i)o.push(this.parser.getDependency("accessor",i[c]).then(f=>(a[c]=f,a[c])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(c=>{const f=c.pop(),l=f.isGroup?f.children:[f],h=c[0].count,p=[];for(const d of l){const g=new I,m=new P,T=new V,y=new P(1,1,1),A=new Jt(d.geometry,d.material,h);for(let w=0;w<h;w++)a.TRANSLATION&&m.fromBufferAttribute(a.TRANSLATION,w),a.ROTATION&&T.fromBufferAttribute(a.ROTATION,w),a.SCALE&&y.fromBufferAttribute(a.SCALE,w),A.setMatrixAt(w,g.compose(m,T,y));for(const w in a)if(w==="_COLOR_0"){const v=a[w];A.instanceColor=new en(v.array,v.itemSize,v.normalized)}else w!=="TRANSLATION"&&w!=="ROTATION"&&w!=="SCALE"&&d.geometry.setAttribute(w,a[w]);se.prototype.copy.call(A,d),this.parser.assignFinalMaterial(A),p.push(A)}return f.isGroup?(f.clear(),f.add(...p),f):p[0]}))}}const Gt="glTF",ce=12,lt={JSON:1313821514,BIN:5130562};class Fs{constructor(e){this.name=E.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,ce),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Gt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-ce,r=new DataView(e,ce);let i=0;for(;i<n;){const o=r.getUint32(i,!0);i+=4;const a=r.getUint32(i,!0);if(i+=4,a===lt.JSON){const c=new Uint8Array(e,ce+i,o);this.content=s.decode(c)}else if(a===lt.BIN){const c=ce+i;this.body=e.slice(c,c+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Cs{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=E.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,o={},a={},c={};for(const f in i){const l=We[f]||f.toLowerCase();o[l]=i[f]}for(const f in e.attributes){const l=We[f]||f.toLowerCase();if(i[f]!==void 0){const h=s.accessors[e.attributes[f]],p=oe[h.componentType];c[l]=p.name,a[l]=h.normalized===!0}}return t.getDependency("bufferView",r).then(function(f){return new Promise(function(l,h){n.decodeDracoFile(f,function(p){for(const d in p.attributes){const g=p.attributes[d],m=a[d];m!==void 0&&(g.normalized=m)}l(p)},o,c,z,h)})})}}class Ps{constructor(){this.name=E.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Ds{constructor(){this.name=E.KHR_MESH_QUANTIZATION}}class Ht extends yn{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let i=0;i!==n;i++)t[i]=s[r+i];return t}interpolate_(e,t,s,n){const r=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=o*2,c=o*3,f=n-t,l=(s-t)/f,h=l*l,p=h*l,d=e*c,g=d-c,m=-2*p+3*h,T=p-h,y=1-m,A=T-h+l;for(let w=0;w!==o;w++){const v=i[g+w+o],R=i[g+w+a]*f,S=i[d+w+o],b=i[d+w]*f;r[w]=y*v+A*R+m*S+T*b}return r}}const Os=new V;class ks extends Ht{interpolate_(e,t,s,n){const r=super.interpolate_(e,t,s,n);return Os.fromArray(r).normalize().toArray(r),r}}const B={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},oe={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ut={9728:It,9729:Xe,9984:un,9985:fn,9986:hn,9987:St},ft={33071:Be,33648:pn,10497:pe},Oe={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},We={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Y={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Ns={CUBICSPLINE:void 0,LINEAR:Mt,STEP:dn},ke={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Bs(u){return u.DefaultMaterial===void 0&&(u.DefaultMaterial=new Lt({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:mn})),u.DefaultMaterial}function Q(u,e,t){for(const s in t.extensions)u[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function X(u,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(u.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Gs(u,e,t){let s=!1,n=!1,r=!1;for(let c=0,f=e.length;c<f;c++){const l=e[c];if(l.POSITION!==void 0&&(s=!0),l.NORMAL!==void 0&&(n=!0),l.COLOR_0!==void 0&&(r=!0),s&&n&&r)break}if(!s&&!n&&!r)return Promise.resolve(u);const i=[],o=[],a=[];for(let c=0,f=e.length;c<f;c++){const l=e[c];if(s){const h=l.POSITION!==void 0?t.getDependency("accessor",l.POSITION):u.attributes.position;i.push(h)}if(n){const h=l.NORMAL!==void 0?t.getDependency("accessor",l.NORMAL):u.attributes.normal;o.push(h)}if(r){const h=l.COLOR_0!==void 0?t.getDependency("accessor",l.COLOR_0):u.attributes.color;a.push(h)}}return Promise.all([Promise.all(i),Promise.all(o),Promise.all(a)]).then(function(c){const f=c[0],l=c[1],h=c[2];return s&&(u.morphAttributes.position=f),n&&(u.morphAttributes.normal=l),r&&(u.morphAttributes.color=h),u.morphTargetsRelative=!0,u})}function Hs(u,e){if(u.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)u.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(u.morphTargetInfluences.length===t.length){u.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)u.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Us(u){let e;const t=u.extensions&&u.extensions[E.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Ne(t.attributes):e=u.indices+":"+Ne(u.attributes)+":"+u.mode,u.targets!==void 0)for(let s=0,n=u.targets.length;s<n;s++)e+=":"+Ne(u.targets[s]);return e}function Ne(u){let e="";const t=Object.keys(u).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+u[t[s]]+";";return e}function qe(u){switch(u){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Vs(u){return u.search(/\.jpe?g($|\?)/i)>0||u.search(/^data\:image\/jpeg/)===0?"image/jpeg":u.search(/\.webp($|\?)/i)>0||u.search(/^data\:image\/webp/)===0?"image/webp":u.search(/\.ktx2($|\?)/i)>0||u.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const js=new I;class Ks{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new hs,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,r=!1,i=-1;if(typeof navigator<"u"){const o=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(o)===!0;const a=o.match(/Version\/(\d+)/);n=s&&a?parseInt(a[1],10):-1,r=o.indexOf("Firefox")>-1,i=r?o.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||r&&i<98?this.textureLoader=new dt(this.options.manager):this.textureLoader=new tn(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Ye(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(i){const o={scene:i[0][n.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:n.asset,parser:s,userData:{}};return Q(r,o,n),X(o,n),Promise.all(s._invokeAll(function(a){return a.afterRoot&&a.afterRoot(o)})).then(function(){for(const a of o.scenes)a.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let o=0,a=i.length;o<a;o++)e[i[o]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const i=e[n];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(s[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),r=(i,o)=>{const a=this.associations.get(i);a!=null&&this.associations.set(o,a);for(const[c,f]of i.children.entries())r(f,o.children[c])};return r(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(r,i){return s.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[E.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,i){s.load(ie.resolveURL(t.uri,n.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const i=Oe[n.type],o=oe[n.componentType],a=n.normalized===!0,c=new o(n.count*i);return Promise.resolve(new Me(c,i,a))}const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(i){const o=i[0],a=Oe[n.type],c=oe[n.componentType],f=c.BYTES_PER_ELEMENT,l=f*a,h=n.byteOffset||0,p=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,d=n.normalized===!0;let g,m;if(p&&p!==l){const T=Math.floor(h/p),y="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+T+":"+n.count;let A=t.cache.get(y);A||(g=new c(o,T*p,n.count*p/f),A=new nn(g,p/f),t.cache.add(y,A)),m=new gn(A,a,h%p/f,d)}else o===null?g=new c(n.count*a):g=new c(o,h,n.count*a),m=new Me(g,a,d);if(n.sparse!==void 0){const T=Oe.SCALAR,y=oe[n.sparse.indices.componentType],A=n.sparse.indices.byteOffset||0,w=n.sparse.values.byteOffset||0,v=new y(i[1],A,n.sparse.count*T),R=new c(i[2],w,n.sparse.count*a);o!==null&&(m=new Me(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let S=0,b=v.length;S<b;S++){const F=v[S];if(m.setX(F,R[S*a]),a>=2&&m.setY(F,R[S*a+1]),a>=3&&m.setZ(F,R[S*a+2]),a>=4&&m.setW(F,R[S*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=d}return m})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,i=t.images[r];let o=this.textureLoader;if(i.uri){const a=s.manager.getHandler(i.uri);a!==null&&(o=a)}return this.loadTextureImage(e,r,o)}loadTextureImage(e,t,s){const n=this,r=this.json,i=r.textures[e],o=r.images[t],a=(o.uri||o.bufferView)+":"+i.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(t,s).then(function(f){f.flipY=!1,f.name=i.name||o.name||"",f.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(f.name=o.uri);const h=(r.samplers||{})[i.sampler]||{};return f.magFilter=ut[h.magFilter]||Xe,f.minFilter=ut[h.minFilter]||St,f.wrapS=ft[h.wrapS]||pe,f.wrapT=ft[h.wrapT]||pe,f.generateMipmaps=!f.isCompressedTexture&&f.minFilter!==It&&f.minFilter!==Xe,n.associations.set(f,{textures:e}),f}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(e,t){const s=this,n=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(l=>l.clone());const i=n.images[e],o=self.URL||self.webkitURL;let a=i.uri||"",c=!1;if(i.bufferView!==void 0)a=s.getDependency("bufferView",i.bufferView).then(function(l){c=!0;const h=new Blob([l],{type:i.mimeType});return a=o.createObjectURL(h),a});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const f=Promise.resolve(a).then(function(l){return new Promise(function(h,p){let d=h;t.isImageBitmapLoader===!0&&(d=function(g){const m=new Ge(g);m.needsUpdate=!0,h(m)}),t.load(ie.resolveURL(l,r.path),d,void 0,p)})}).then(function(l){return c===!0&&o.revokeObjectURL(a),X(l,i),l.userData.mimeType=i.mimeType||Vs(i.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),l});return this.sourceCache[e]=f,f}assignTexture(e,t,s,n){const r=this;return this.getDependency("texture",s.index).then(function(i){if(!i)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(i=i.clone(),i.channel=s.texCoord),r.extensions[E.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[E.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const a=r.associations.get(i);i=r.extensions[E.KHR_TEXTURE_TRANSFORM].extendTexture(i,o),r.associations.set(i,a)}}return n!==void 0&&(i.colorSpace=n),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let a=this.cache.get(o);a||(a=new sn,be.prototype.copy.call(a,s),a.color.copy(s.color),a.map=s.map,a.sizeAttenuation=!1,this.cache.add(o,a)),s=a}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let a=this.cache.get(o);a||(a=new wt,be.prototype.copy.call(a,s),a.color.copy(s.color),a.map=s.map,this.cache.add(o,a)),s=a}if(n||r||i){let o="ClonedMaterial:"+s.uuid+":";n&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),i&&(o+="flat-shading:");let a=this.cache.get(o);a||(a=s.clone(),r&&(a.vertexColors=!0),i&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(o,a),this.associations.set(a,this.associations.get(s))),s=a}e.material=s}getMaterialType(){return Lt}loadMaterial(e){const t=this,s=this.json,n=this.extensions,r=s.materials[e];let i;const o={},a=r.extensions||{},c=[];if(a[E.KHR_MATERIALS_UNLIT]){const l=n[E.KHR_MATERIALS_UNLIT];i=l.getMaterialType(),c.push(l.extendParams(o,r,t))}else{const l=r.pbrMetallicRoughness||{};if(o.color=new O(1,1,1),o.opacity=1,Array.isArray(l.baseColorFactor)){const h=l.baseColorFactor;o.color.setRGB(h[0],h[1],h[2],z),o.opacity=h[3]}l.baseColorTexture!==void 0&&c.push(t.assignTexture(o,"map",l.baseColorTexture,C)),o.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,o.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(o,"metalnessMap",l.metallicRoughnessTexture)),c.push(t.assignTexture(o,"roughnessMap",l.metallicRoughnessTexture))),i=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,o)})))}r.doubleSided===!0&&(o.side=rn);const f=r.alphaMode||ke.OPAQUE;if(f===ke.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,f===ke.MASK&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==le&&(c.push(t.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new Qe(1,1),r.normalTexture.scale!==void 0)){const l=r.normalTexture.scale;o.normalScale.set(l,l)}if(r.occlusionTexture!==void 0&&i!==le&&(c.push(t.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==le){const l=r.emissiveFactor;o.emissive=new O().setRGB(l[0],l[1],l[2],z)}return r.emissiveTexture!==void 0&&i!==le&&c.push(t.assignTexture(o,"emissiveMap",r.emissiveTexture,C)),Promise.all(c).then(function(){const l=new i(o);return r.name&&(l.name=r.name),X(l,r),t.associations.set(l,{materials:e}),r.extensions&&Q(n,l,r),l})}createUniqueName(e){const t=de.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function r(o){return s[E.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(a){return ht(a,o,t)})}const i=[];for(let o=0,a=e.length;o<a;o++){const c=e[o],f=Us(c),l=n[f];if(l)i.push(l.promise);else{let h;c.extensions&&c.extensions[E.KHR_DRACO_MESH_COMPRESSION]?h=r(c):h=ht(new ye,c,t),n[f]={primitive:c,promise:h},i.push(h)}}return Promise.all(i)}loadMesh(e){const t=this,s=this.json,n=this.extensions,r=s.meshes[e],i=r.primitives,o=[];for(let a=0,c=i.length;a<c;a++){const f=i[a].material===void 0?Bs(this.cache):this.getDependency("material",i[a].material);o.push(f)}return o.push(t.loadGeometries(i)),Promise.all(o).then(function(a){const c=a.slice(0,a.length-1),f=a[a.length-1],l=[];for(let p=0,d=f.length;p<d;p++){const g=f[p],m=i[p];let T;const y=c[p];if(m.mode===B.TRIANGLES||m.mode===B.TRIANGLE_STRIP||m.mode===B.TRIANGLE_FAN||m.mode===void 0)T=r.isSkinnedMesh===!0?new At(g,y):new yt(g,y),T.isSkinnedMesh===!0&&T.normalizeSkinWeights(),m.mode===B.TRIANGLE_STRIP?T.geometry=ct(T.geometry,Rt):m.mode===B.TRIANGLE_FAN&&(T.geometry=ct(T.geometry,Ke));else if(m.mode===B.LINES)T=new on(g,y);else if(m.mode===B.LINE_STRIP)T=new xt(g,y);else if(m.mode===B.LINE_LOOP)T=new an(g,y);else if(m.mode===B.POINTS)T=new cn(g,y);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(T.geometry.morphAttributes).length>0&&Hs(T,r),T.name=t.createUniqueName(r.name||"mesh_"+e),X(T,r),m.extensions&&Q(n,T,m),t.assignFinalMaterial(T),l.push(T)}for(let p=0,d=l.length;p<d;p++)t.associations.set(l[p],{meshes:e,primitives:p});if(l.length===1)return r.extensions&&Q(n,l[0],r),l[0];const h=new ue;r.extensions&&Q(n,h,r),t.associations.set(h,{meshes:e});for(let p=0,d=l.length;p<d;p++)h.add(l[p]);return h})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new mt(D.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new ln(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),X(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,r=t.joints.length;n<r;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const r=n.pop(),i=n,o=[],a=[];for(let c=0,f=i.length;c<f;c++){const l=i[c];if(l){o.push(l);const h=new I;r!==null&&h.fromArray(r.array,c*16),a.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new Et(o,a)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],r=n.name?n.name:"animation_"+e,i=[],o=[],a=[],c=[],f=[];for(let l=0,h=n.channels.length;l<h;l++){const p=n.channels[l],d=n.samplers[p.sampler],g=p.target,m=g.node,T=n.parameters!==void 0?n.parameters[d.input]:d.input,y=n.parameters!==void 0?n.parameters[d.output]:d.output;g.node!==void 0&&(i.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",T)),a.push(this.getDependency("accessor",y)),c.push(d),f.push(g))}return Promise.all([Promise.all(i),Promise.all(o),Promise.all(a),Promise.all(c),Promise.all(f)]).then(function(l){const h=l[0],p=l[1],d=l[2],g=l[3],m=l[4],T=[];for(let y=0,A=h.length;y<A;y++){const w=h[y],v=p[y],R=d[y],S=g[y],b=m[y];if(w===void 0)continue;w.updateMatrix&&w.updateMatrix();const F=s._createAnimationTracks(w,v,R,S,b);if(F)for(let N=0;N<F.length;N++)T.push(F[N])}return new vt(r,void 0,T)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(r){const i=s._getNodeRef(s.meshCache,n.mesh,r);return n.weights!==void 0&&i.traverse(function(o){if(o.isMesh)for(let a=0,c=n.weights.length;a<c;a++)o.morphTargetInfluences[a]=n.weights[a]}),i})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],r=s._loadNodeShallow(e),i=[],o=n.children||[];for(let c=0,f=o.length;c<f;c++)i.push(s.getDependency("node",o[c]));const a=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([r,Promise.all(i),a]).then(function(c){const f=c[0],l=c[1],h=c[2];h!==null&&f.traverse(function(p){p.isSkinnedMesh&&p.bind(h,js)});for(let p=0,d=l.length;p<d;p++)f.add(l[p]);return f})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?n.createUniqueName(r.name):"",o=[],a=n._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return a&&o.push(a),r.camera!==void 0&&o.push(n.getDependency("camera",r.camera).then(function(c){return n._getNodeRef(n.cameraCache,r.camera,c)})),n._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){o.push(c)}),this.nodeCache[e]=Promise.all(o).then(function(c){let f;if(r.isBone===!0?f=new He:c.length>1?f=new ue:c.length===1?f=c[0]:f=new se,f!==c[0])for(let l=0,h=c.length;l<h;l++)f.add(c[l]);if(r.name&&(f.userData.name=r.name,f.name=i),X(f,r),r.extensions&&Q(s,f,r),r.matrix!==void 0){const l=new I;l.fromArray(r.matrix),f.applyMatrix4(l)}else r.translation!==void 0&&f.position.fromArray(r.translation),r.rotation!==void 0&&f.quaternion.fromArray(r.rotation),r.scale!==void 0&&f.scale.fromArray(r.scale);return n.associations.has(f)||n.associations.set(f,{}),n.associations.get(f).nodes=e,f}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,r=new ue;s.name&&(r.name=n.createUniqueName(s.name)),X(r,s),s.extensions&&Q(t,r,s);const i=s.nodes||[],o=[];for(let a=0,c=i.length;a<c;a++)o.push(n.getDependency("node",i[a]));return Promise.all(o).then(function(a){for(let f=0,l=a.length;f<l;f++)r.add(a[f]);const c=f=>{const l=new Map;for(const[h,p]of n.associations)(h instanceof be||h instanceof Ge)&&l.set(h,p);return f.traverse(h=>{const p=n.associations.get(h);p!=null&&l.set(h,p)}),l};return n.associations=c(r),r})}_createAnimationTracks(e,t,s,n,r){const i=[],o=e.name?e.name:e.uuid,a=[];Y[r.path]===Y.weights?e.traverse(function(h){h.morphTargetInfluences&&a.push(h.name?h.name:h.uuid)}):a.push(o);let c;switch(Y[r.path]){case Y.weights:c=je;break;case Y.rotation:c=xe;break;case Y.position:case Y.scale:c=Ve;break;default:switch(s.itemSize){case 1:c=je;break;case 2:case 3:default:c=Ve;break}break}const f=n.interpolation!==void 0?Ns[n.interpolation]:Mt,l=this._getArrayFromAccessor(s);for(let h=0,p=a.length;h<p;h++){const d=new c(a[h]+"."+Y[r.path],t.array,l,f);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(d),i.push(d)}return i}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=qe(t.constructor),n=new Float32Array(t.length);for(let r=0,i=t.length;r<i;r++)n[r]=t[r]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof xe?ks:Ht;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Xs(u,e,t){const s=e.attributes,n=new Tn;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],a=o.min,c=o.max;if(a!==void 0&&c!==void 0){if(n.set(new P(a[0],a[1],a[2]),new P(c[0],c[1],c[2])),o.normalized){const f=qe(oe[o.componentType]);n.min.multiplyScalar(f),n.max.multiplyScalar(f)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const o=new P,a=new P;for(let c=0,f=r.length;c<f;c++){const l=r[c];if(l.POSITION!==void 0){const h=t.json.accessors[l.POSITION],p=h.min,d=h.max;if(p!==void 0&&d!==void 0){if(a.setX(Math.max(Math.abs(p[0]),Math.abs(d[0]))),a.setY(Math.max(Math.abs(p[1]),Math.abs(d[1]))),a.setZ(Math.max(Math.abs(p[2]),Math.abs(d[2]))),h.normalized){const g=qe(oe[h.componentType]);a.multiplyScalar(g)}o.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}u.boundingBox=n;const i=new An;n.getCenter(i.center),i.radius=n.min.distanceTo(n.max)/2,u.boundingSphere=i}function ht(u,e,t){const s=e.attributes,n=[];function r(i,o){return t.getDependency("accessor",i).then(function(a){u.setAttribute(o,a)})}for(const i in s){const o=We[i]||i.toLowerCase();o in u.attributes||n.push(r(s[i],o))}if(e.indices!==void 0&&!u.index){const i=t.getDependency("accessor",e.indices).then(function(o){u.setIndex(o)});n.push(i)}return j.workingColorSpace!==z&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${j.workingColorSpace}" not supported.`),X(u,e),Xs(u,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Gs(u,e.targets,t):u})}class zs{loader=new Jn;isSupported(e){return e.toLowerCase().endsWith("fbx")}async load(e){return new Promise((t,s)=>{this.loader.load(e,n=>{const r=n.animations[0];t({object:n,animation:r})},void 0,s)})}}class Ws{loader=new fs;isSupported(e){return e.toLowerCase().endsWith("gltf")}async load(e){return new Promise((t,s)=>{this.loader.load(e,n=>{t({object:n.scene,gltf:n})},void 0,s)})}}class nr{loaders=[new zs,new Ws];async loadFile(e){const t=this.loaders.find(s=>s.isSupported(e));if(!t)throw new Error(`Unsupported file type: ${e}`);return t.load(e)}}const pt={id:"zylem",globals:{},stages:[Sn()]};function qs(u){let e={...pt};const t=[],s=[],n=[];return Object.values(u).forEach(r=>{if(r instanceof Rn)s.push(r);else if(r instanceof In)n.push(r);else if(r instanceof wn)n.push(r);else if(r.constructor.name==="Object"&&typeof r=="object"){const i=Object.assign(pt,{...r});t.push(i)}}),t.forEach(r=>{e=Object.assign(e,{...r})}),s.forEach(r=>{r.addEntities(n)}),s.length?e.stages=s:e.stages[0].addEntities(n),e}class Ys{gameRef=null;options;update=()=>{};setup=()=>{};destroy=()=>{};refErrorMessage="lost reference to game";constructor(e){this.options=e}async start(){const e=await this.load();this.gameRef=e,this.setOverrides(),e.start()}async load(){const e=qs(this.options),t=new Ee(e,this);return await t.loadStage(e.stages[0]),t}setOverrides(){if(!this.gameRef){console.error(this.refErrorMessage);return}this.gameRef.customSetup=this.setup,this.gameRef.customUpdate=this.update,this.gameRef.customDestroy=this.destroy}async pause(){}async reset(){if(!this.gameRef){console.error(this.refErrorMessage);return}await this.gameRef.loadStage(this.gameRef.stages[0])}async nextStage(){if(!this.gameRef){console.error(this.refErrorMessage);return}const e=this.gameRef.currentStageId,t=this.gameRef.stages.findIndex(n=>n.stageRef.uuid===e),s=this.gameRef.stages[t+1];if(!s){console.error("next stage called on last stage");return}await this.gameRef.loadStage(s)}async previousStage(){if(!this.gameRef){console.error(this.refErrorMessage);return}const e=this.gameRef.currentStageId,t=this.gameRef.stages.findIndex(n=>n.stageRef.uuid===e),s=this.gameRef.stages[t-1];if(!s){console.error("previous stage called on first stage");return}await this.gameRef.loadStage(s)}async goToStage(){}async end(){}}function sr(...u){return new Ys(u)}export{nr as E,sr as g};
